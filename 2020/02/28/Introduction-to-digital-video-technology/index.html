<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="17哥,17g,17G,17" />
       
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>数字视频技术导论 |  17哥</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
      <script src="https://use.fontawesome.com/39301eb177.js"></script>
    <link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Introduction-to-digital-video-technology"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  数字视频技术导论
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/28/Introduction-to-digital-video-technology/" class="article-date">
  <time datetime="2020-02-28T08:49:46.000Z" itemprop="datePublished">2020-02-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/">视频技术</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">11.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">44 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1>背景</h1>
<p>因为工作关系需要了解数字视频相关技术，在学习的过程中找到了这份托管在github上的<strong>数字视频导论</strong>的材料。</p>
<p>这份材料介绍了基本的数字视频相关技术，言简意赅但又不枯燥无味，即有理论又有丰富的实践操作，在我学习的所有材料中算是比较上乘的材料。</p>
<p>基于如上的原因，将该材料的相关内容转载到此处。大家可以直接访问该材料的github仓库<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/digital_video_introduction"><strong>digital_video_introduction</strong></a>获取相关内容。如下的所有内容皆来自<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/digital_video_introduction"><strong>digital_video_introduction</strong></a>，特此标注。</p>
<p><a href="license-BSD--3--Clause-blue.svg"><img src="/2020/02/28/Introduction-to-digital-video-technology/license-BSD--3--Clause-blue.svg" alt="license"></a></p>
<span id="more"></span>
<h1>介绍</h1>
<p>这是一份循序渐进的视频技术的介绍。尽管它面向的是软件开发人员/工程师，但我们希望<strong>对任何人而言</strong>，这份文档都能简单易学。这个点子产生于一个<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/17Z31kEkl_NGJ0M66reqr9_uTG6tI5EDDVXpdPKVuIrs/edit#slide=id.p">视频技术新手小型研讨会</a>期间。</p>
<p>本文档旨在尽可能使用<strong>浅显的词语，丰富的图像和实际例子</strong>介绍数字视频概念，使这些知识能适用于各种场合。你可以随时反馈意见或建议，以改进这篇文档。</p>
<h1>目录</h1>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD">基本术语</a>
<ul>
<li><a href="#%E7%BC%96%E7%A0%81%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95">编码彩色图像的其它方法</a></li>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E7%8E%A9%E8%BD%AC%E5%9B%BE%E5%83%8F%E5%92%8C%E9%A2%9C%E8%89%B2">自己动手：玩转图像和颜色</a></li>
<li><a href="#DVD-%E7%9A%84-DAR-%E6%98%AF-4-3">DVD 的 DAR 是 4:3</a></li>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E6%A3%80%E6%9F%A5%E8%A7%86%E9%A2%91%E5%B1%9E%E6%80%A7">自己动手：检查视频属性</a></li>
</ul>
</li>
<li><a href="#%E6%B6%88%E9%99%A4%E5%86%97%E4%BD%99">消除冗余</a>
<ul>
<li><a href="#%E9%A2%9C%E8%89%B2%EF%BC%8C%E4%BA%AE%E5%BA%A6%E5%92%8C%E6%88%91%E4%BB%AC%E7%9A%84%E7%9C%BC%E7%9D%9B">颜色，亮度和我们的眼睛</a>
<ul>
<li><a href="#%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B">颜色模型</a></li>
<li><a href="#YCbCr-%E5%92%8C-RGB-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">YCbCr 和 RGB 之间的转换</a></li>
<li><a href="#%E8%89%B2%E5%BA%A6%E5%AD%90%E9%87%87%E6%A0%B7">色度子采样</a></li>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E6%A3%80%E6%9F%A5-YCbCr-%E7%9B%B4%E6%96%B9%E5%9B%BE">自己动手：检查 YCbCr 直方图</a></li>
</ul>
</li>
<li><a href="#%E5%B8%A7%E7%B1%BB%E5%9E%8B">帧类型</a>
<ul>
<li><a href="#I-%E5%B8%A7%EF%BC%88%E5%B8%A7%E5%86%85%E7%BC%96%E7%A0%81%EF%BC%8C%E5%85%B3%E9%94%AE%E5%B8%A7%EF%BC%89">I 帧（内部，关键帧）</a></li>
<li><a href="#P-%E5%B8%A7%EF%BC%88%E9%A2%84%E6%B5%8B%EF%BC%89">P 帧（预测）</a>
<ul>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E5%85%B7%E6%9C%89%E5%8D%95%E4%B8%AA-I-%E5%B8%A7%E7%9A%84%E8%A7%86%E9%A2%91">自己动手：具有单个 I 帧的视频</a></li>
</ul>
</li>
<li><a href="#B-%E5%B8%A7%EF%BC%88%E5%8F%8C%E5%90%91%E9%A2%84%E6%B5%8B%EF%BC%89">B 帧（双向预测）</a>
<ul>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-B-%E5%B8%A7%E6%AF%94%E8%BE%83%E8%A7%86%E9%A2%91">自己动手：使用 B 帧比较视频</a></li>
</ul>
</li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%86%97%E4%BD%99%EF%BC%88%E5%B8%A7%E9%97%B4%E9%A2%84%E6%B5%8B%EF%BC%89">时间冗余（帧间预测）</a>
<ul>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E6%9F%A5%E7%9C%8B%E8%BF%90%E5%8A%A8%E5%90%91%E9%87%8F">自己动手：查看运动向量</a></li>
</ul>
</li>
<li><a href="#%E7%A9%BA%E9%97%B4%E5%86%97%E4%BD%99%EF%BC%88%E5%B8%A7%E5%86%85%E9%A2%84%E6%B5%8B%EF%BC%89">空间冗余（帧内预测）</a>
<ul>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E6%9F%A5%E7%9C%8B%E5%B8%A7%E5%86%85%E9%A2%84%E6%B5%8B">自己动手：查看帧内预测</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F">视频编解码器是如何工作的？</a>
<ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F">是什么？为什么？怎么做？</a></li>
<li><a href="#%E5%8E%86%E5%8F%B2">历史</a>
<ul>
<li><a href="#AV1-%E7%9A%84%E8%AF%9E%E7%94%9F">AV1 的诞生</a></li>
</ul>
</li>
<li><a href="#%E9%80%9A%E7%94%A8%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8">通用编解码器</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E6%AD%A5-%E5%9B%BE%E7%89%87%E5%88%86%E5%8C%BA">第一步 - 图片分区</a>
<ul>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E6%9F%A5%E7%9C%8B%E5%88%86%E5%8C%BA">自己动手：查看分区</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E9%A2%84%E6%B5%8B">第二步 - 预测</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%AD%A5-%E8%BD%AC%E6%8D%A2">第三步 - 转换</a>
<ul>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E4%B8%A2%E5%BC%83%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B3%BB%E6%95%B0">自己动手：丢弃不同的系数</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5-%E9%87%8F%E5%8C%96">第四步 - 量化</a>
<ul>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E9%87%8F%E5%8C%96">自己动手：量化</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%94%E6%AD%A5-%E7%86%B5%E7%BC%96%E7%A0%81">第五步 - 熵编码</a>
<ul>
<li><a href="#VLC-%E7%BC%96%E7%A0%81%EF%BC%9A">VLC 编码</a></li>
<li><a href="#%E7%AE%97%E6%9C%AF%E7%BC%96%E7%A0%81">算术编码</a></li>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9ACABAC-vs-CAVLC">自己动手：CABAC vs CAVLC</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%85%AD%E6%AD%A5-%E6%AF%94%E7%89%B9%E6%B5%81%E6%A0%BC%E5%BC%8F">第六步 - 比特流格式</a>
<ul>
<li><a href="#H-264-%E6%AF%94%E7%89%B9%E6%B5%81">H.264 比特流</a></li>
<li><a href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%9A%E6%A3%80%E6%9F%A5-H-264-%E6%AF%94%E7%89%B9%E6%B5%81">自己动手：检查 H.264 比特流</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9E%E9%A1%BE">回顾</a></li>
<li><a href="#H-265-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AF%94-H-264-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%8E%87">H.265 如何实现比 H.264 更好的压缩率?</a></li>
</ul>
</li>
<li><a href="#%E5%9C%A8%E7%BA%BF%E6%B5%81%E5%AA%92%E4%BD%93">在线流媒体</a>
<ul>
<li><a href="#%E9%80%9A%E7%94%A8%E6%9E%B6%E6%9E%84">通用架构</a></li>
<li><a href="#%E6%B8%90%E8%BF%9B%E5%BC%8F%E4%B8%8B%E8%BD%BD%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E6%B5%81">渐进式下载和自适应流</a></li>
<li><a href="#%E5%86%85%E5%AE%B9%E4%BF%9D%E6%8A%A4">内容保护</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-jupyter">如何使用 jupyter</a></li>
<li><a href="#%E4%BC%9A%E8%AE%AE">会议</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<h1>基本术语</h1>
<p>一个<strong>图像</strong>可以视作一个<strong>二维矩阵</strong>。如果将<strong>色彩</strong>考虑进来，我们可以做出推广：将这个图像视作一个<strong>三维矩阵</strong>——多出来的维度用于储存色彩信息。</p>
<p>如果我们选择三原色（红、绿、蓝）代表这些色彩，这就定义了三个平面：第一个是红色平面，第二个是绿色平面，最后一个是蓝色平面。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/image_3d_matrix_rgb.png" alt="an image is a 3d matrix RGB" title="An image is a 3D matrix"></p>
<p>我们把这个矩阵里的每一个点称为<strong>像素</strong>（图像元素）。像素的色彩由三原色的<strong>强度</strong>（通常用数值表示）表示。例如，一个<strong>红色像素</strong>是指强度为 0 的绿色，强度为 0 的蓝色和强度最大的红色。<strong>粉色像素</strong>可以通过三种颜色的组合表示。如果规定强度的取值范围是 0 到 255，<strong>红色 255、绿色 192、蓝色 203</strong> 则表示粉色。</p>
<blockquote>
<h3 id="编码彩色图像的其它方法">编码彩色图像的其它方法</h3>
<p>还有许多其它模型也可以用来表示色彩，进而组成图像。例如，给每种颜色都标上序号（如下图），这样每个像素仅需一个字节就可以表示出来，而不是 RGB 模型通常所需的 3 个。在这样一个模型里我们可以用一个二维矩阵来代替三维矩阵去表示我们的色彩，这将节省存储空间，但色彩的数量将会受限。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/nes-color-palette.png" alt="NES palette" title="NES palette"></p>
</blockquote>
<p>例如以下几张图片。第一张包含所有颜色平面。剩下的分别是红、绿、蓝色平面（显示为灰调）（译注：颜色强度高的地方显示为亮色，强度低为暗色）。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/rgb_channels_intensity.png" alt="RGB channels intensity" title="RGB channels intensity"></p>
<p>我们可以看到，对于最终的成像，红色平面对强度的贡献更多（三个平面最亮的是红色平面），蓝色平面（最后一张图片）的贡献大多只在马里奥的眼睛和他衣服的一部分。所有颜色平面对马里奥的胡子（最暗的部分）均贡献较少。</p>
<p>存储颜色的强度，需要占用一定大小的数据空间，这个大小被称为颜色深度。假如每个颜色（平面）的强度占用 8 bit（取值范围为 0 到 255），那么颜色深度就是 24（8*3）bit，我们还可以推导出我们可以使用 2 的 24 次方种不同的颜色。</p>
<blockquote>
<p>很棒的学习材料：<a target="_blank" rel="noopener" href="http://www.cambridgeincolour.com/tutorials/camera-sensors.htm">现实世界的照片是如何拍摄成 0 和 1 的</a>。</p>
</blockquote>
<p>图片的另一个属性是<strong>分辨率</strong>，即一个平面内像素的数量。通常表示成宽*高，例如下面这张 <strong>4x4</strong> 的图片。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/resolution.png" alt="image resolution" title="image resolution"></p>
<blockquote>
<h3 id="自己动手：玩转图像和颜色">自己动手：玩转图像和颜色</h3>
<p>你可以使用 <a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-jupyter">jupyter</a>（python, numpy, matplotlib 等等）<a target="_blank" rel="noopener" href="https://gitee.com/wangwei1237/wangwei1237/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/image_as_3d_array.ipynb">玩转图像</a>。</p>
<p>你也可以学习<a target="_blank" rel="noopener" href="https://gitee.com/wangwei1237/wangwei1237/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/filters_are_easy.ipynb">图像滤镜（边缘检测，磨皮，模糊。。。）的原理</a>。</p>
</blockquote>
<p>图像或视频还有一个属性是宽高比，它简单地描述了图像或像素的宽度和高度之间的比例关系。</p>
<p>当人们说这个电影或照片是 16:9 时，通常是指显示宽高比（DAR），然而我们也可以有不同形状的单个像素，我们称为像素宽高比（PAR）。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/DAR.png" alt="display aspect ratio" title="display aspect ratio"></p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/PAR.png" alt="pixel aspect ratio" title="pixel aspect ratio"></p>
<blockquote>
<h2 id="dvd-的-dar-是-4-3">DVD 的 DAR 是 4:3</h2>
<p>虽然 DVD 的实际分辨率是 704x480，但它依然保持 4:3 的宽高比，因为它有一个 10:11（704x10／480x11）的 PAR。</p>
</blockquote>
<p>现在我们可以将<strong>视频</strong>定义为在<strong>单位时间</strong>内<strong>连续的 n 帧</strong>，这可以视作一个新的维度，n 即为帧率，若单位时间为秒，则等同于 FPS (每秒帧数 Frames Per Second)。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/video.png" alt="video" title="video"></p>
<p>播放一段视频每秒所需的数据量就是它的<strong>比特率</strong>（即常说的码率）。</p>
<blockquote>
<p>比特率 = 宽 * 高 * 颜色深度 * 帧每秒</p>
</blockquote>
<p>例如，一段每秒 30 帧，每像素 24 bits，分辨率是 480x240 的视频，如果我们不做任何压缩，它将需要 <strong>82,944,000 比特每秒</strong>或 82.944 Mbps (30x480x240x24)。</p>
<p>当<strong>比特率</strong>几乎恒定时称为恒定比特率（<strong>CBR</strong>）；但它也可以变化，称为可变比特率（<strong>VBR</strong>）。</p>
<blockquote>
<p>这个图形显示了一个受限的 VBR，当帧为黑色时不会花费太多的数据量。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/vbr.png" alt="constrained vbr" title="constrained vbr"></p>
</blockquote>
<p>在早期，工程师们想出了一项技术能将视频的感官帧率加倍而<strong>没有消耗额外带宽</strong>。这项技术被称为<strong>隔行扫描</strong>；总的来说，它在一个时间点发送一个画面——画面用于填充屏幕的一半，而下一个时间点发送的画面用于填充屏幕的另一半。</p>
<p>如今的屏幕渲染大多使用<strong>逐行扫描技术</strong>。这是一种显示、存储、传输运动图像的方法，每帧中的所有行都会被依次绘制。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/interlaced_vs_progressive.png" alt="interlaced vs progressive" title="interlaced vs progressive"></p>
<p>现在我们知道了数字化<strong>图像</strong>的原理；它的<strong>颜色</strong>的编排方式；给定<strong>帧率</strong>和<strong>分辨率</strong>时，展示一个视频需要花费多少<strong>比特率</strong>；它是恒定的（CBR）还是可变的（VBR）；还有很多其它内容，如隔行扫描和 PAR。</p>
<blockquote>
<h2 id="自己动手：检查视频属性">自己动手：检查视频属性</h2>
<p>你可以<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/introduction_video_technology/blob/master/encoding_pratical_examples.md#inspect-stream">使用 ffmpeg 或 mediainfo 检查大多数属性的解释</a>。</p>
</blockquote>
<h1>消除冗余</h1>
<p>我们认识到，不对视频进行压缩是不行的；<strong>一个单独的一小时长的视频</strong>，分辨率为 720p 和 30fps 时将<strong>需要 278GB<sup>*</sup></strong>。仅仅使用无损数据压缩算法——如 DEFLATE（被PKZIP, Gzip, 和 PNG 使用）——也无法充分减少视频所需的带宽，我们需要找到其它压缩视频的方法。</p>
<blockquote>
<p><sup>*</sup>我们使用乘积得出这个数字 1280 x 720 x 24 x 30 x 3600 （宽，高，每像素比特数，fps 和秒数）</p>
</blockquote>
<p>为此，我们可以<strong>利用视觉特性</strong>：和区分颜色相比，我们区分亮度要更加敏锐。<strong>时间上的重复</strong>：一段视频包含很多只有一点小小改变的图像。<strong>图像内的重复</strong>：每一帧也包含很多颜色相同或相似的区域。</p>
<h2 id="颜色-亮度和我们的眼睛">颜色，亮度和我们的眼睛</h2>
<p>我们的眼睛<a target="_blank" rel="noopener" href="http://vanseodesign.com/web-design/color-luminance/">对亮度比对颜色更敏感</a>，你可以看看下面的图片自己测试。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/luminance_vs_color.png" alt="luminance vs color" title="luminance vs color"></p>
<p>如果你看不出左图的<strong>方块 A 和方块 B</strong> 的颜色是<strong>相同的</strong>，那么好，是我们的大脑玩了一个小把戏，这让我们更多的去注意光与暗，而不是颜色。右边这里有一个使用同样颜色的连接器，那么我们（的大脑）就能轻易分辨出事实，它们是同样的颜色。</p>
<blockquote>
<p><strong>简单解释我们的眼睛工作的原理</strong></p>
<p><a target="_blank" rel="noopener" href="http://www.biologymad.com/nervoussystem/eyenotes.htm">眼睛是一个复杂的器官</a>，有许多部分组成，但我们最感兴趣的是视锥细胞和视杆细胞。眼睛有<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Photoreceptor_cell">大约1.2亿个视杆细胞和6百万个视锥细胞</a>。</p>
<p><strong>简单来说</strong>，让我们把颜色和亮度放在眼睛的功能部位上。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rod_cell">视杆细胞</a><strong>主要负责亮度</strong>，而<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cone_cell">视锥细胞</a><strong>负责颜色</strong>，有三种类型的视锥，每个都有不同的颜料，叫做：<a target="_blank" rel="noopener" href="https://upload.wikimedia.org/wikipedia/commons/1/1e/Cones_SMJ2_E.svg">S-视锥（蓝色），M-视锥（绿色）和L-视锥（红色）</a>。</p>
<p>既然我们的视杆细胞（亮度）比视锥细胞多很多，一个合理的推断是相比颜色，我们有更好的能力去区分黑暗和光亮。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/eyes.jpg" alt="eyes composition" title="eyes composition"></p>
</blockquote>
<p>一旦我们知道我们对<strong>亮度</strong>（图像中的亮度）更敏感，我们就可以利用它。</p>
<h3 id="颜色模型">颜色模型</h3>
<p>我们最开始学习的<a href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD">彩色图像的原理</a>使用的是 <strong>RGB 模型</strong>，但也有其他模型。有一种模型将亮度（光亮）和色度（颜色）分离开，它被称为 <strong>YCbCr</strong><sup>*</sup>。</p>
<blockquote>
<p><sup>*</sup> 有很多种模型做同样的分离。</p>
</blockquote>
<p>这个颜色模型使用 <strong>Y</strong> 来表示亮度，还有两种颜色通道：Cb（蓝色色度） 和 Cr（红色色度）。YCbCr 可以由 RGB 转换得来，也可以转换回 RGB。使用这个模型我们可以创建拥有完整色彩的图像，如下图。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/ycbcr.png" alt="ycbcr 例子" title="ycbcr 例子"></p>
<h3 id="ycbcr-和-rgb-之间的转换">YCbCr 和 RGB 之间的转换</h3>
<p>有人可能会问，在**不使用绿色（色度）**的情况下，我们如何表现出所有的色彩？</p>
<p>为了回答这个问题，我们将介绍从 RGB 到 YCbCr 的转换。我们将使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ITU-R">ITU-R 小组</a>*建议的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rec._601">标准 BT.601</a> 中的系数。</p>
<p>第一步是计算亮度，我们将使用 ITU 建议的常量，并替换 RGB 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y &#x3D; 0.299R + 0.587G + 0.114B</span><br></pre></td></tr></table></figure>
<p>一旦我们有了亮度后，我们就可以拆分颜色（蓝色色度和红色色度）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cb &#x3D; 0.564(B - Y)</span><br><span class="line">Cr &#x3D; 0.713(R - Y)</span><br></pre></td></tr></table></figure>
<p>并且我们也可以使用 YCbCr 转换回来，甚至得到绿色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R &#x3D; Y + 1.402Cr</span><br><span class="line">B &#x3D; Y + 1.772Cb</span><br><span class="line">G &#x3D; Y - 0.344Cb - 0.714Cr</span><br></pre></td></tr></table></figure>
<blockquote>
<p><sup>*</sup>组织和标准在数字视频领域中很常见，它们通常定义什么是标准，例如，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rec._2020">什么是 4K？我们应该使用什么帧率？分辨率？颜色模型？</a></p>
</blockquote>
<p>通常，<strong>显示屏</strong>（监视器，电视机，屏幕等等）<strong>仅使用 RGB 模型</strong>，并以不同的方式来组织，看看下面这些放大效果：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/new_pixel_geometry.jpg" alt="pixel geometry" title="pixel geometry"></p>
<h3 id="色度子采样">色度子采样</h3>
<p>一旦我们能从图像中分离出亮度和色度，我们就可以利用人类视觉系统对亮度比色度更敏感的特点，选择性地剔除信息。<strong>色度子采样</strong>是一种编码图像时，使<strong>色度分辨率低于亮度</strong>的技术。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/ycbcr_subsampling_resolution.png" alt="ycbcr 子采样分辨率" title="ycbcr 子采样分辨率"></p>
<p>我们应该减少多少色度分辨率呢？已经有一些模式定义了如何处理分辨率和合并（<code>最终的颜色 = Y + Cb + Cr</code>）。</p>
<p>这些模式称为子采样系统，并被表示为 3 部分的比率 - <code>a:x:y</code>，其定义了色度平面的分辨率，与亮度平面上的、分辨率为 <code>a x 2</code> 的小块之间的关系。</p>
<ul>
<li><code>a</code> 是水平采样参考 (通常是 4)，</li>
<li><code>x</code> 是第一行的色度样本数（相对于 a 的水平分辨率），</li>
<li><code>y</code> 是第二行的色度样本数。</li>
</ul>
<blockquote>
<p>存在的一个例外是 4:1:0，其在每个亮度平面分辨率为 4 x 4 的块内提供一个色度样本。</p>
</blockquote>
<p>现代编解码器中使用的常用方案是： 4:4:4 (没有子采样)**, 4:2:2, 4:1:1, 4:2:0, 4:1:0 and 3:1:1。</p>
<blockquote>
<p>YCbCr 4:2:0 合并</p>
<p>这是使用 YCbCr 4:2:0 合并的一个图像的一块，注意我们每像素只花费 12bit。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/ycbcr_420_merge.png" alt="YCbCr 4:2:0 合并" title="YCbCr 4:2:0 合并"></p>
</blockquote>
<p>下图是同一张图片使用几种主要的色度子采样技术进行编码，第一行图像是最终的 YCbCr，而最后一行图像展示了色度的分辨率。这么小的损失确实是一个伟大的胜利。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/chroma_subsampling_examples.jpg" alt="色度子采样例子" title="色度子采样例子"></p>
<p>前面我们计算过我们需要 <a href="#%E6%B6%88%E9%99%A4%E5%86%97%E4%BD%99">278GB 去存储一个一小时长，分辨率在720p和30fps的视频文件</a>。如果我们使用 <code>YCbCr 4:2:0</code> 我们能剪掉<code>一半的大小（139GB）</code><sup>*</sup>，但仍然不够理想。</p>
<blockquote>
<p><sup>*</sup> 我们通过将宽、高、颜色深度和 fps 相乘得出这个值。前面我们需要 24 bit，现在我们只需要 12 bit。</p>
</blockquote>
<blockquote>
<h3 id="自己动手：检查-ycbcr-直方图">自己动手：检查 YCbCr 直方图</h3>
<p>你可以<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#generates-yuv-histogram">使用 ffmpeg 检查 YCbCr 直方图</a>。这个场景有更多的蓝色贡献，由<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Histogram">直方图</a>显示。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/yuv_histogram.png" alt="ycbcr 颜色直方图" title="ycbcr 颜色直方图"></p>
</blockquote>
<h2 id="帧类型">帧类型</h2>
<p>现在我们进一步消除<code>时间冗余</code>，但在这之前让我们来确定一些基本术语。假设我们一段 30fps 的影片，这是最开始的 4 帧。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_1.png" alt="球 1" title="球 1"> <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_2.png" alt="球 2" title="球 2"> <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_3.png" alt="球 3" title="球 3"><br>
<img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_4.png" alt="球 4" title="球 4"></p>
<p>我们可以在帧内看到<strong>很多重复内容</strong>，如<strong>蓝色背景</strong>，从 0 帧到第 3 帧它都没有变化。为了解决这个问题，我们可以将它们<strong>抽象地分类</strong>为三种类型的帧。</p>
<h3 id="i-帧-帧内编码-关键帧">I 帧（帧内编码，关键帧）</h3>
<p>I 帧（可参考，关键帧，帧内编码）是一个<strong>自足的帧</strong>。它不依靠任何东西来渲染，I 帧与静态图片相似。第一帧通常是 I 帧，但我们将看到 I 帧被定期插入其它类型的帧之间。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_1.png" alt="球 1" title="球 1"></p>
<h3 id="p-帧-预测">P 帧（预测）</h3>
<p>P 帧利用了一个事实：当前的画面几乎总能<strong>使用之前的一帧进行渲染</strong>。例如，在第二帧，唯一的改变是球向前移动了。仅仅使用（第二帧）对前一帧的引用和差值，我们就能重建前一帧。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_1.png" alt="球 1" title="球 1"> &lt;-  <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_2_diff.png" alt="球 2" title="球 2"></p>
<blockquote>
<h4 id="自己动手：具有单个-i-帧的视频">自己动手：具有单个 I 帧的视频</h4>
<p>既然 P 帧使用较少的数据，为什么我们不能用<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#1-i-frame-and-the-rest-p-frames">单个 I 帧和其余的 P 帧</a>来编码整个视频？</p>
<p>编码完这个视频之后，开始观看它，并<strong>快进到视频的末尾部分</strong>，你会注意到<strong>它需要花一些时间</strong>才真正跳转到这部分。这是因为 <strong>P 帧需要一个引用帧</strong>（比如 I 帧）才能渲染。</p>
<p>你可以做的另一个快速试验，是使用单个 I 帧编码视频，然后<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#1-i-frames-per-second-vs-05-i-frames-per-second">再次编码且每 2 秒插入一个 I 帧</a>，并<strong>比较成品的大小</strong>。</p>
</blockquote>
<h3 id="b-帧-双向预测">B 帧（双向预测）</h3>
<p>如何引用前面和后面的帧去做更好的压缩？！简单地说 B 帧就是这么做的。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_1.png" alt="球 1" title="球 1"> &lt;-  <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_2_diff.png" alt="球 2" title="球 2"> -&gt; <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_3.png" alt="球 3" title="球 3"></p>
<blockquote>
<h4 id="自己动手：使用-b-帧比较视频">自己动手：使用 B 帧比较视频</h4>
<p>你可以生成两个版本，一个使用 B 帧，另一个<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#no-b-frames-at-all">全部不使用 B 帧</a>，然后查看文件的大小以及画质。</p>
</blockquote>
<h3 id="小结">小结</h3>
<p>这些帧类型用于提供更好的压缩率，我们将在下一章看到这是如何发生的。现在，我们可以想到 I 帧是昂贵的，P 帧是便宜的，最便宜的是 B 帧。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/frame_types.png" alt="帧类型例子" title="帧类型例子"></p>
<h2 id="时间冗余-帧间预测">时间冗余（帧间预测）</h2>
<p>让我们探究去除<strong>时间上的重复</strong>，去除这一类冗余的技术就是<strong>帧间预测</strong>。</p>
<p>我们将尝试<strong>花费较少的数据量</strong>去编码在时间上连续的 0 号帧和 1 号帧。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/original_frames.png" alt="原始帧" title="原始帧"></p>
<p>我们可以做个减法，我们简单地<strong>用 0 号帧减去 1 号帧</strong>，得到残差，这样我们就只需要<strong>对残差进行编码</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/difference_frames.png" alt="残差帧" title="残差帧"></p>
<p>但我们有一个<strong>更好的方法</strong>来节省数据量。首先，我们将<code>0 号帧</code> 视为一个个分块的集合，然后我们将尝试将 <code>帧 1</code> 和 <code>帧 0</code> 上的块相匹配。我们可以将这看作是<strong>运动预测</strong>。</p>
<blockquote>
<h3 id="维基百科-块运动补偿">维基百科—块运动补偿</h3>
<p>“运动补偿是一种描述相邻帧（相邻在这里表示在编码关系上相邻，在播放顺序上两帧未必相邻）差别的方法，具体来说是描述前面一帧（相邻在这里表示在编码关系上的前面，在播放顺序上未必在当前帧前面）的每个小块怎样移动到当前帧中的某个位置去。”</p>
</blockquote>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/original_frames_motion_estimation.png" alt="原始帧运动预测" title="原始帧运动预测"></p>
<p>我们预计那个球会从 <code>x=0, y=25</code> 移动到 <code>x=6, y=26</code>，<strong>x</strong> 和 <strong>y</strong> 的值就是<strong>运动向量</strong>。<strong>进一步</strong>节省数据量的方法是，只编码这两者运动向量的差。所以，最终运动向量就是 <code>x=6 (6-0), y=1 (26-25)</code>。</p>
<blockquote>
<p>实际情况下，这个球会被切成 n 个分区，但处理过程是相同的。</p>
</blockquote>
<p>帧上的物体<strong>以三维方式移动</strong>，当球移动到背景时会变小。当我们尝试寻找匹配的块，<strong>找不到完美匹配的块</strong>是正常的。这是一张运动预测与实际值相叠加的图片。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/motion_estimation.png" alt="运动预测" title="运动预测"></p>
<p>但我们能看到当我们使用<strong>运动预测</strong>时，<strong>编码的数据量少于</strong>使用简单的残差帧技术。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/comparison_delta_vs_motion_estimation.png" alt="运动预测 vs 残差 " title="运动预测 vs 残差"></p>
<p>你可以<a target="_blank" rel="noopener" href="https://gitee.com/wangwei1237/wangwei1237/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/frame_difference_vs_motion_estimation_plus_residual.ipynb">使用 jupyter 玩转这些概念</a>。</p>
<blockquote>
<h3 id="自己动手：查看运动向量">自己动手：查看运动向量</h3>
<p>我们可以<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#generate-debug-video">使用 ffmpeg 生成包含帧间预测（运动向量）的视频</a>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/motion_vectors_ffmpeg.png" alt="ffmpeg 帧间预测（运动向量）" title="ffmpeg 帧间预测（运动向量）"></p>
<p>或者我们也可使用 <a target="_blank" rel="noopener" href="https://software.intel.com/en-us/intel-video-pro-analyzer">Intel® Video Pro Analyzer</a>（需要付费，但也有只能查看前 10 帧的免费试用版）。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/inter_prediction_intel_video_pro_analyzer.png" alt="Intel® Video Pro Analyzer 使用帧间预测" title="inter prediction intel video pro analyzer"></p>
</blockquote>
<h2 id="空间冗余-帧内预测">空间冗余（帧内预测）</h2>
<p>如果我们分析一个视频里的<strong>每一帧</strong>，我们会看到有<strong>许多区域是相互关联的</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/repetitions_in_space.png" alt="空间内重复" title="空间内重复"></p>
<p>让我们举一个例子。这个场景大部分由蓝色和白色组成。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_bg.png" alt="smw 背景" title="smw 背景"></p>
<p>这是一个 <code>I 帧</code>，我们<strong>不能使用前面的帧来预测</strong>，但我们仍然可以压缩它。我们将编码我们选择的那块红色区域。如果我们<strong>看看它的周围</strong>，我们可以<strong>估计它周围颜色的变化</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_bg_block.png" alt="smw 背景块" title="smw 背景块"></p>
<p>我们预测:帧中的颜色在垂直方向上保持一致，这意味着<strong>未知像素的颜色与临近的像素相同</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_bg_prediction.png" alt="smw 背景预测" title="smw 背景预测"></p>
<p>我们的<strong>预测会出错</strong>，所以我们需要先利用这项技术（<strong>帧内预测</strong>），然后<strong>减去实际值</strong>，算出残差，得出的矩阵比原始数据更容易压缩。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_residual.png" alt="smw 残差" title="smw 残差"></p>
<blockquote>
<h3 id="自己动手：查看帧内预测">自己动手：查看帧内预测</h3>
<p>你可以<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#generate-debug-video">使用 ffmpeg 生成包含宏块及预测的视频</a>。请查看 ffmpeg 文档以了解<a target="_blank" rel="noopener" href="https://trac.ffmpeg.org/wiki/Debug/MacroblocksAndMotionVectors">每个块颜色的含义</a>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/macro_blocks_ffmpeg.png" alt="ffmpeg 帧内预测（宏块）" title="ffmpeg 帧内预测（宏块）"></p>
<p>或者我们也可使用 <a target="_blank" rel="noopener" href="https://software.intel.com/en-us/intel-video-pro-analyzer">Intel® Video Pro Analyzer</a>（需要付费，但也有只能查看前 10 帧的免费试用版）。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/intra_prediction_intel_video_pro_analyzer.png" alt="Intel® Video Pro Analyzer 帧内预测" title="Intel® Video Pro Analyzer 帧内预测"></p>
</blockquote>
<h1>视频编解码器是如何工作的？</h1>
<h2 id="是什么？为什么？怎么做？">是什么？为什么？怎么做？</h2>
<p><strong>是什么？</strong> 就是用于压缩或解压数字视频的软件或硬件。<strong>为什么？</strong> 人们需要在有限带宽或存储空间下提高视频的质量。还记得当我们计算每秒 30 帧，每像素 24 bit，分辨率是 480x240 的视频<a href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD">需要多少带宽</a>吗？没有压缩时是 <strong>82.944 Mbps</strong>。电视或互联网提供 HD/FullHD/4K 只能靠视频编解码器。<strong>怎么做？</strong> 我们将简单介绍一下主要的技术。</p>
<blockquote>
<p>视频编解码 vs 容器</p>
<p>初学者一个常见的错误是混淆数字视频编解码器和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Digital_container_format">数字视频容器</a>。我们可以将<strong>容器</strong>视为包含视频（也很可能包含音频）元数据的包装格式，<strong>压缩过的视频</strong>可以看成是它承载的内容。</p>
<p>通常，视频文件的格式定义其视频容器。例如，文件 <code>video.mp4</code> 可能是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MPEG-4_Part_14">MPEG-4 Part 14</a> 容器，一个叫 <code>video.mkv</code> 的文件可能是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Matroska">matroska</a>。我们可以使用 <a target="_blank" rel="noopener" href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#inspect-stream">ffmpeg 或 mediainfo</a> 来完全确定编解码器和容器格式。</p>
</blockquote>
<h2 id="历史">历史</h2>
<p>在我们跳进通用编解码器内部工作之前，让我们回头了解一些旧的视频编解码器。</p>
<p>视频编解码器 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/H.261">H.261</a> 诞生在 1990（技术上是 1988），被设计为以 <strong>64 kbit/s 的数据速率</strong>工作。它已经使用如色度子采样、宏块，等等理念。在 1995 年，<strong>H.263</strong> 视频编解码器标准被发布，并继续延续到 2001 年。</p>
<p>在 2003 年 <strong>H.264/AVC</strong> 的第一版被完成。在同一年，一家叫做 <strong>TrueMotion</strong> 的公司发布了他们的<strong>免版税</strong>有损视频压缩的视频编解码器，称为 <strong>VP3</strong>。在 2008 年，<strong>Google 收购了</strong>这家公司，在同一年发布 <strong>VP8</strong>。在 2012 年 12 月，Google 发布了 <strong>VP9</strong>，<strong>市面上大约有 3/4 的浏览器</strong>（包括手机）支持。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/AOMedia_Video_1">AV1</a> 是由 <strong>Google, Mozilla, Microsoft, Amazon, Netflix, AMD, ARM, NVidia, Intel, Cisco</strong> 等公司组成的<a target="_blank" rel="noopener" href="http://aomedia.org/">开放媒体联盟（AOMedia）</a>设计的一种新的视频编解码器，免版税，开源。<strong>第一版</strong> 0.1.0 参考编解码器<strong>发布于 2016 年 4 月 7 号</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/codec_history_timeline.png" alt="编解码器历史线路图" title="编解码器历史线路图"></p>
<blockquote>
<h3 id="av1-的诞生">AV1 的诞生</h3>
<p>2015 年早期，Google 正在 VP10 上工作，Xiph (Mozilla) 正在 Daala 上工作，Cisco 开源了它的称为 Thor 的免版税视频编解码器。</p>
<p>接着 MPEG LA 宣布了 HEVC (H.265) 每年版税的的上限，比 H.264 高 8 倍，但很快他们又再次改变了条款：</p>
<ul>
<li><strong>不设年度收费上限</strong></li>
<li><strong>收取内容费</strong>（收入的 0.5%）</li>
<li><strong>每单位费用高于 h264 的 10 倍</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://aomedia.org/about-us/">开放媒体联盟</a>由硬件厂商（Intel, AMD, ARM , Nvidia, Cisco），内容分发商（Google, Netflix, Amazon），浏览器维护者（Google, Mozilla），等公司创建。</p>
<p>这些公司有一个共同目标，一个免版税的视频编解码器，所以 AV1 诞生时使用了一个更<a target="_blank" rel="noopener" href="http://aomedia.org/license/patent/">简单的专利许可证</a>。<strong>Timothy B. Terriberry</strong> 做了一个精彩的介绍，<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=lzPaldsmJbk">关于 AV1 的概念，许可证模式和它当前的状态</a>，就是本节的来源。</p>
<p>前往 <a target="_blank" rel="noopener" href="http://aomanalyzer.org/">http://aomanalyzer.org/</a>， 你会惊讶于<strong>使用你的浏览器就可以分析 AV1 编解码器</strong>。<br>
<img src="/2020/02/28/Introduction-to-digital-video-technology/av1_browser_analyzer.png" alt="av1 浏览器分析器" title="浏览器分析器"></p>
<p>附：如果你想了解更多编解码器的历史，你需要了解<a target="_blank" rel="noopener" href="https://www.vcodex.com/video-compression-patents/">视频压缩专利</a>背后的基本知识。</p>
</blockquote>
<h2 id="通用编解码器">通用编解码器</h2>
<p>我们接下来要介绍<strong>通用视频编解码器背后的主要机制</strong>，大多数概念都很实用，并被现代编解码器如 VP9, AV1 和 HEVC 使用。需要注意：我们将简化许多内容。有时我们会使用真实的例子（主要是 H.264）来演示技术。</p>
<h2 id="第一步-图片分区">第一步 - 图片分区</h2>
<p>第一步是<strong>将帧</strong>分成几个<strong>分区</strong>，<strong>子分区</strong>甚至更多。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/picture_partitioning.png" alt="图片分区" title="图片分区"></p>
<p>**但是为什么呢？**有许多原因，比如，当我们分割图片时，我们可以更精确的处理预测，在微小移动的部分使用较小的分区，而在静态背景上使用较大的分区。</p>
<p>通常，编解码器<strong>将这些分区组织</strong>成切片（或瓦片），宏（或编码树单元）和许多子分区。这些分区的最大大小有所不同，HEVC 设置成 64x64，而 AVC 使用 16x16，但子分区可以达到 4x4 的大小。</p>
<p>还记得我们学过的<strong>帧的分类</strong>吗？你也可以<strong>把这些概念应用到块</strong>，因此我们可以有 I 切片，B 切片，I 宏块等等。</p>
<blockquote>
<h3 id="自己动手：查看分区">自己动手：查看分区</h3>
<p>我们也可以使用 <a target="_blank" rel="noopener" href="https://software.intel.com/en-us/intel-video-pro-analyzer">Intel® Video Pro Analyzer</a>（需要付费，但也有只能查看前 10 帧的免费试用版）。这是 <a target="_blank" rel="noopener" href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#transcoding">VP9 分区</a>的分析。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/paritions_view_intel_video_pro_analyzer.png" alt="Intel® Video Pro Analyzer VP9 分区视图 " title="Intel® Video Pro Analyzer VP9 分区视图"></p>
</blockquote>
<h2 id="第二步-预测">第二步 - 预测</h2>
<p>一旦我们有了分区，我们就可以在它们之上做出预测。对于<a href="#%E6%97%B6%E9%97%B4%E5%86%97%E4%BD%99%EF%BC%88%E5%B8%A7%E9%97%B4%E9%A2%84%E6%B5%8B%EF%BC%89">帧间预测</a>，我们需要<strong>发送运动向量和残差</strong>；至于<a href="#%E7%A9%BA%E9%97%B4%E5%86%97%E4%BD%99%EF%BC%88%E5%B8%A7%E5%86%85%E9%A2%84%E6%B5%8B%EF%BC%89">帧内预测</a>，我们需要<strong>发送预测方向和残差</strong>。</p>
<h2 id="第三步-转换">第三步 - 转换</h2>
<p>在我们得到残差块（<code>预测分区-真实分区</code>）之后，我们可以用一种方式<strong>变换</strong>它，这样我们就知道<strong>哪些像素我们应该丢弃</strong>，还依然能保持<strong>整体质量</strong>。这个确切的行为有几种变换方式。</p>
<p>尽管有<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_Fourier-related_transforms#Discrete_transforms">其它的变换方式</a>，但我们重点关注离散余弦变换（DCT）。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Discrete_cosine_transform">DCT</a> 的主要功能有：</p>
<ul>
<li>将<strong>像素</strong>块<strong>转换</strong>为相同大小的<strong>频率系数块</strong>。</li>
<li><strong>压缩</strong>能量，更容易消除空间冗余。</li>
<li><strong>可逆的</strong>，也意味着你可以还原回像素。</li>
</ul>
<blockquote>
<p>2017 年 2 月 2 号，F. M. Bayer 和 R. J. Cintra 发表了他们的论文：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1702.00817">图像压缩的 DCT 类变换只需要 14 个加法</a>。</p>
</blockquote>
<p>如果你不理解每个要点的好处，不用担心，我们会尝试进行一些实验，以便从中看到真正的价值。</p>
<p>我们来看下面的<strong>像素块</strong>（8x8）：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/pixel_matrice.png" alt="像素值矩形" title="像素值矩形"></p>
<p>下面是其渲染的块图像（8x8）：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/gray_image.png" alt="像素值矩形" title="像素值矩形"></p>
<p>当我们对这个像素块<strong>应用 DCT</strong> 时， 得到如下<strong>系数块</strong>（8x8）：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/dct_coefficient_values.png" alt="系数值 values" title="系数值"></p>
<p>接着如果我们渲染这个系数块，就会得到这张图片：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/dct_coefficient_image.png" alt="dct 系数图片" title="dct 系数图片"></p>
<p>如你所见它看起来完全不像原图像，我们可能会注意到<strong>第一个系数</strong>与其它系数非常不同。第一个系数被称为直流分量，代表了输入数组中的<strong>所有样本</strong>，有点<strong>类似于平均值</strong>。</p>
<p>这个系数块有一个有趣的属性：高频部分和低频部分是分离的。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/dctfrequ.jpg" alt="dct 频率系数属性" title="dct 频率系数属性"></p>
<p>在一张图像中，<strong>大多数能量</strong>会集中在<a target="_blank" rel="noopener" href="https://www.iem.thm.de/telekom-labor/zinke/mk/mpeg2beg/whatisit.htm">低频部分</a>，所以如果我们将图像转换成频率系数，并<strong>丢掉高频系数</strong>，我们就能<strong>减少描述图像所需的数据量</strong>，而不会牺牲太多的图像质量。</p>
<blockquote>
<p>频率是指信号变化的速度。</p>
</blockquote>
<p>让我们通过实验学习这点，我们将使用 DCT 把原始图像转换为频率（系数块），然后丢掉最不重要的系数。</p>
<p>首先，我们将它转换为其<strong>频域</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/dct_coefficient_values.png" alt="系数值" title="系数值"></p>
<p>然后我们丢弃部分（67%）系数，主要是它的右下角部分。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/dct_coefficient_zeroed.png" alt="系数清零" title="系数清零"></p>
<p>然后我们从丢弃的系数块重构图像（记住，这需要可逆），并与原始图像相比较。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/original_vs_quantized.png" alt="原始 vs 量化" title="原始 vs 量化"></p>
<p>如我们所见它酷似原始图像，但它引入了许多与原来的不同，我们<strong>丢弃了67.1875%</strong>，但我们仍然得到至少类似于原来的东西。我们可以更加智能的丢弃系数去得到更好的图像质量，但这是下一个主题。</p>
<blockquote>
<h3 id="使用全部像素形成每个系数">使用全部像素形成每个系数</h3>
<p>重要的是要注意，每个系数并不直接映射到单个像素，但它是所有像素的加权和。这个神奇的图形展示了如何计算出第一和第二个系数，使用每个唯一的索引做权重。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/applicat.jpg" alt="dct 计算" title="dct 计算"></p>
<p>来源：<a target="_blank" rel="noopener" href="https://web.archive.org/web/20150129171151/https://www.iem.thm.de/telekom-labor/zinke/mk/mpeg2beg/whatisit.htm">https://web.archive.org/web/20150129171151/https://www.iem.thm.de/telekom-labor/zinke/mk/mpeg2beg/whatisit.htm</a></p>
<p>你也可以尝试<a target="_blank" rel="noopener" href="https://gitee.com/wangwei1237/wangwei1237/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/dct_better_explained.ipynb">通过查看在 DCT 基础上形成的简单图片来可视化 DCT</a>。例如，这是使用每个系数权重<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Discrete_cosine_transform#Example_of_IDCT">形成的字符 A</a>。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/5e/Idct-animation.gif" alt></p>
</blockquote>
<br>
<blockquote>
<h3 id="自己动手：丢弃不同的系数">自己动手：丢弃不同的系数</h3>
<p>你可以玩转 <a target="_blank" rel="noopener" href="https://gitee.com/wangwei1237/wangwei1237/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/uniform_quantization_experience.ipynb">DCT 变换</a></p>
</blockquote>
<h2 id="第四步-量化">第四步 - 量化</h2>
<p>当我们丢弃一些系数时，在最后一步（变换），我们做了一些形式的量化。这一步，我们选择性地剔除信息（<strong>有损部分</strong>）或者简单来说，我们将<strong>量化系数以实现压缩</strong>。</p>
<p>我们如何量化一个系数块？一个简单的方法是均匀量化，我们取一个块并<strong>将其除以单个的值</strong>（10），并舍入值。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/quantize.png" alt="量化" title="量化"></p>
<p>我们如何<strong>逆转</strong>（重新量化）这个系数块？我们可以通过<strong>乘以我们先前除以的相同的值</strong>（10）来做到。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/re-quantize.png" alt="逆转量化" title="逆转量化"></p>
<p>这<strong>不是最好的方法</strong>，因为它没有考虑到每个系数的重要性，我们可以使用一个<strong>量化矩阵</strong>来代替单个值，这个矩阵可以利用 DCT 的属性，多量化右下部，而少（量化）左上部，<a target="_blank" rel="noopener" href="https://www.hdm-stuttgart.de/~maucher/Python/MMCodecs/html/jpegUpToQuant.html">JPEG 使用了类似的方法</a>，你可以通过<a target="_blank" rel="noopener" href="https://github.com/google/guetzli/blob/master/guetzli/jpeg_data.h#L40">查看源码看看这个矩阵</a>。</p>
<blockquote>
<h3 id="自己动手：量化">自己动手：量化</h3>
<p>你可以玩转<a target="_blank" rel="noopener" href="https://gitee.com/wangwei1237/wangwei1237/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/dct_experiences.ipynb">量化</a></p>
</blockquote>
<h2 id="第五步-熵编码">第五步 - 熵编码</h2>
<p>在我们量化数据（图像块／切片／帧）之后，我们仍然可以以无损的方式来压缩它。有许多方法（算法）可用来压缩数据。我们将简单体验其中几个，你可以阅读这本很棒的书去深入理解：<a target="_blank" rel="noopener" href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/">Understanding Compression: Data Compression for Modern Developers</a>。</p>
<h3 id="vlc-编码：">VLC 编码：</h3>
<p>让我们假设我们有一个符号流：<strong>a</strong>, <strong>e</strong>, <strong>r</strong> 和 <strong>t</strong>，它们的概率（从0到1）由下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>e</th>
<th>r</th>
<th>t</th>
</tr>
</thead>
<tbody>
<tr>
<td>概率</td>
<td>0.3</td>
<td>0.3</td>
<td>0.2</td>
<td>0.2</td>
</tr>
</tbody>
</table>
<p>我们可以分配不同的二进制码，（最好是）小的码给最可能（出现的字符），大些的码给最少可能（出现的字符）。</p>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>e</th>
<th>r</th>
<th>t</th>
</tr>
</thead>
<tbody>
<tr>
<td>概率</td>
<td>0.3</td>
<td>0.3</td>
<td>0.2</td>
<td>0.2</td>
</tr>
<tr>
<td>二进制码</td>
<td>0</td>
<td>10</td>
<td>110</td>
<td>1110</td>
</tr>
</tbody>
</table>
<p>让我们压缩 <strong>eat</strong> 流，假设我们为每个字符花费 8 bit，在没有做任何压缩时我们将花费 <strong>24 bit</strong>。但是在这种情况下，我们使用各自的代码来替换每个字符，我们就能节省空间。</p>
<p>第一步是编码字符 <strong>e</strong> 为 <code>10</code>，第二个字符是 <strong>a</strong>，追加（不是数学加法）后是 <code>[10][0]</code>，最后是第三个字符 <strong>t</strong>，最终组成已压缩的比特流 <code>[10][0][1110]</code> 或 <code>1001110</code>，这只需 <strong>7 bit</strong>（比原来的空间少 3.4 倍）。</p>
<p>请注意每个代码必须是唯一的前缀码，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman 能帮你找到这些数字</a>。虽然它有一些问题，但是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Context-adaptive_variable-length_coding">视频编解码器仍然提供该方法</a>，它也是很多应用程序的压缩算法。</p>
<p>编码器和解码器都<strong>必须知道</strong>这个（包含编码的）字符表，因此，你也需要传送这个表。</p>
<h3 id="算术编码">算术编码</h3>
<p>让我们假设我们有一个符号流：<strong>a</strong>, <strong>e</strong>, <strong>r</strong>, <strong>s</strong> 和 <strong>t</strong>，它们的概率由下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>e</th>
<th>r</th>
<th>s</th>
<th>t</th>
</tr>
</thead>
<tbody>
<tr>
<td>概率</td>
<td>0.3</td>
<td>0.3</td>
<td>0.15</td>
<td>0.05</td>
<td>0.2</td>
</tr>
</tbody>
</table>
<p>考虑到这个表，我们可以构建一个区间，区间包含了所有可能的字符，字符按出现概率排序。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/range.png" alt="初始算法区间" title="初始算法区间"></p>
<p>让我们编码 <strong>eat</strong> 流，我们选择第一个字符 <strong>e</strong> 位于 <strong>0.3 到 0.6</strong> （但不包括 0.6）的子区间，我们选择这个子区间，按照之前同等的比例再次分割。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/second_subrange.png" alt="第二个子区间" title="第二个子区间"></p>
<p>让我们继续编码我们的流 <strong>eat</strong>，现在使第二个 <strong>a</strong> 字符位于 <strong>0.3 到 0.39</strong> 的区间里，接着再次用同样的方法编码最后的字符 <strong>t</strong>，得到最后的子区间 <strong>0.354 到 0.372</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/arithimetic_range.png" alt="最终算法区间" title="最终算法区间"></p>
<p>我们只需从最后的子区间 0.354 到 0.372 里选择一个数，让我们选择 0.36，不过我们可以选择这个子区间里的任何数。仅靠这个数，我们将可以恢复原始流 <strong>eat</strong>。就像我们在区间的区间里画了一根线来编码我们的流。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/range_show.png" alt="最终区间横断面" title="最终区间横断面"></p>
<p><strong>反向过程</strong>（又名解码）一样简单，用数字 <strong>0.36</strong> 和我们原始区间，我们可以进行同样的操作，不过现在是使用这个数字来还原被编码的流。</p>
<p>在第一个区间，我们发现数字落入了一个子区间，因此，这个子区间是我们的第一个字符，现在我们再次切分这个子区间，像之前一样做同样的过程。我们会注意到 <strong>0.36</strong> 落入了 <strong>a</strong> 的区间，然后我们重复这一过程直到得到最后一个字符 <strong>t</strong>（形成我们原始编码过的流 eat）。</p>
<p>编码器和解码器都<strong>必须知道</strong>字符概率表，因此，你也需要传送这个表。</p>
<p>非常巧妙，不是吗？人们能想出这样的解决方案实在是太聪明了，一些<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Context-adaptive_binary_arithmetic_coding">视频编解码器使用</a>这项技术（或至少提供这一选择）。</p>
<p>关于无损压缩量化比特流的办法，这篇文章无疑缺少了很多细节、原因、权衡等等。作为一个开发者你<a target="_blank" rel="noopener" href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/">应该学习更多</a>。刚入门视频编码的人可以尝试使用不同的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Asymmetric_Numeral_Systems">熵编码算法，如ANS</a>。</p>
<blockquote>
<h3 id="自己动手：cabac-vs-cavlc">自己动手：CABAC vs CAVLC</h3>
<p>你可以<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/introduction_video_technology/blob/master/encoding_pratical_examples.md#cabac-vs-cavlc">生成两个流，一个使用 CABAC，另一个使用 CAVLC</a>，并比较生成每一个的时间以及最终的大小。</p>
</blockquote>
<h2 id="第六步-比特流格式">第六步 - 比特流格式</h2>
<p>完成所有这些步之后，我们需要将<strong>压缩过的帧和内容打包进去</strong>。需要明确告知解码器<strong>编码定义</strong>，如颜色深度，颜色空间，分辨率，预测信息（运动向量，帧内预测方向），配置<sup>*</sup>，层级<sup>*</sup>，帧率，帧类型，帧号等等更多信息。</p>
<blockquote>
<p><sup>*</sup> 译注：原文为 profile 和 level，没有通用的译名</p>
</blockquote>
<p>我们将简单地学习 H.264 比特流。第一步是<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/introduction_video_technology/blob/master/encoding_pratical_examples.md#generate-a-single-frame-h264-bitstream">生成一个小的 H.264<sup>*</sup> 比特流</a>，可以使用本 repo 和 <a target="_blank" rel="noopener" href="http://ffmpeg.org/">ffmpeg</a> 来做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;s&#x2F;ffmpeg -i &#x2F;files&#x2F;i&#x2F;minimal.png -pix_fmt yuv420p &#x2F;files&#x2F;v&#x2F;minimal_yuv420.h264</span><br></pre></td></tr></table></figure>
<blockquote>
<p><sup>*</sup> ffmpeg 默认将所有参数添加为 <strong>SEI NAL</strong>，很快我们会定义什么是 NAL。</p>
</blockquote>
<p>这个命令会使用下面的图片作为帧，生成一个具有<strong>单个帧</strong>，64x64 和颜色空间为 yuv420 的原始 h264 比特流。</p>
<blockquote>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/minimal.png" alt="使用帧来生成极简 h264 比特流" title="使用帧来生成极简 h264 比特流"></p>
</blockquote>
<h3 id="h-264-比特流">H.264 比特流</h3>
<p>AVC (H.264) 标准规定信息将在宏帧（网络概念上的）内传输，称为 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_Abstraction_Layer">NAL</a>（网络抽象层）。NAL 的主要目标是提供“网络友好”的视频呈现方式，该标准必须适用于电视（基于流），互联网（基于数据包）等。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/nal_units.png" alt="H.264 NAL 单元" title="H.264 NAL 单元"></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Frame_synchronization">同步标记</a>用来定义 NAL 单元的边界。每个同步标记的值固定为  <code>0x00 0x00 0x01</code> ，最开头的标记例外，它的值是  <code>0x00 0x00 0x00 0x01</code> 。如果我们在生成的 h264 比特流上运行 <strong>hexdump</strong>，我们可以在文件的开头识别至少三个 NAL。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/minimal_yuv420_hex.png" alt="NAL 单元上的同步标记" title="NAL 单元上的同步标记"></p>
<p>我们之前说过，解码器需要知道不仅仅是图片数据，还有视频的详细信息，如：帧、颜色、使用的参数等。每个 NAL 的<strong>第一位</strong>定义了其分类和<strong>类型</strong>。</p>
<table>
<thead>
<tr>
<th>NAL type id</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Undefined</td>
</tr>
<tr>
<td>1</td>
<td>Coded slice of a non-IDR picture</td>
</tr>
<tr>
<td>2</td>
<td>Coded slice data partition A</td>
</tr>
<tr>
<td>3</td>
<td>Coded slice data partition B</td>
</tr>
<tr>
<td>4</td>
<td>Coded slice data partition C</td>
</tr>
<tr>
<td>5</td>
<td><strong>IDR</strong> Coded slice of an IDR picture</td>
</tr>
<tr>
<td>6</td>
<td><strong>SEI</strong> Supplemental enhancement information</td>
</tr>
<tr>
<td>7</td>
<td><strong>SPS</strong> Sequence parameter set</td>
</tr>
<tr>
<td>8</td>
<td><strong>PPS</strong> Picture parameter set</td>
</tr>
<tr>
<td>9</td>
<td>Access unit delimiter</td>
</tr>
<tr>
<td>10</td>
<td>End of sequence</td>
</tr>
<tr>
<td>11</td>
<td>End of stream</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>通常，比特流的第一个 NAL 是 <strong>SPS</strong>，这个类型的 NAL 负责传达通用编码参数，如<strong>配置，层级，分辨率</strong>等。</p>
<p>如果我们跳过第一个同步标记，就可以通过解码<strong>第一个字节</strong>来了解第一个 <strong>NAL 的类型</strong>。</p>
<p>例如同步标记之后的第一个字节是 <code>01100111</code>，第一位（<code>0</code>）是 <strong>forbidden_zero_bit</strong> 字段，接下来的两位（<code>11</code>）告诉我们是 <strong>nal_ref_idc</strong> 字段，其表示该 NAL 是否是参考字段，其余 5 位（<code>00111</code>）告诉我们是 <strong>nal_unit_type</strong> 字段，在这个例子里是 NAL 单元 <strong>SPS</strong> (7)。</p>
<p>SPS NAL 的第 2 位 (<code>binary=01100100, hex=0x64, dec=100</code>) 是 <strong>profile_idc</strong> 字段，显示编码器使用的配置，在这个例子里，我们使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC#Profiles">受限高配置</a>，一种没有 B（双向预测） 切片支持的高配置。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/minimal_yuv420_bin.png" alt="SPS 二进制视图" title="SPS 二进制视图"></p>
<p>当我们阅读 SPS NAL 的 H.264 比特流规范时，会为<strong>参数名称</strong>，<strong>分类</strong>和<strong>描述</strong>找到许多值，例如，看看字段 <code>pic_width_in_mbs_minus_1</code> 和 <code>pic_height_in_map_units_minus_1</code>。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pic_width_in_mbs_minus_1</td>
<td>0</td>
<td>ue(v)</td>
</tr>
<tr>
<td>pic_height_in_map_units_minus_1</td>
<td>0</td>
<td>ue(v)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>ue(v)</strong>: 无符号整形 <a target="_blank" rel="noopener" href="https://pythonhosted.org/bitstring/exp-golomb.html">Exp-Golomb-coded</a></p>
</blockquote>
<p>如果我们对这些字段的值进行一些计算，将最终得出<strong>分辨率</strong>。我们可以使用值为 <code>119（ (119 + 1) * macroblock_size = 120 * 16 = 1920）</code>的 <code>pic_width_in_mbs_minus_1</code> 表示 <code>1920 x 1080</code>，再次为了减少空间，我们使用 <code>119</code> 来代替编码 <code>1920</code>。</p>
<p>如果我们再次使用二进制视图检查我们创建的视频 (ex: <code>xxd -b -c 11 v/minimal_yuv420.h264</code>)，可以跳到帧自身上一个 NAL。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/slice_nal_idr_bin.png" alt="h264 idr 切片头" title="h264 idr 切片头"></p>
<p>我们可以看到最开始的 6 个字节：<code>01100101 10001000 10000100 00000000 00100001 11111111</code>。我们已经知道第一个字节告诉我们 NAL 的类型，在这个例子里， (<code>00101</code>) 是 <strong>IDR 切片 (5)</strong>，可以进一步检查它：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/slice_header.png" alt="h264 切片头规格" title="h264 切片头规格"></p>
<p>对照规范，我们能解码切片的类型（<strong>slice_type</strong>），帧号（<strong>frame_num</strong>）等重要字段。</p>
<p>为了获得一些字段（<code>ue(v), me(v), se(v) 或 te(v)</code>）的值，我们需要称为 <a target="_blank" rel="noopener" href="https://pythonhosted.org/bitstring/exp-golomb.html">Exponential-Golomb</a> 的特定解码器来解码它。当存在很多默认值时，这个方法编码变量值特别高效。</p>
<blockquote>
<p>这个视频里 <strong>slice_type</strong> 和 <strong>frame_num</strong> 的值是 7（I 切片）和 0（第一帧）。</p>
</blockquote>
<p>我们可以将<strong>比特流视为一个协议</strong>，如果你想学习更多关于比特流的内容，请参考 <a target="_blank" rel="noopener" href="http://www.itu.int/rec/T-REC-H.264-201610-I">ITU H.264 规范</a>。这个宏观图展示了图片数据（压缩过的 YUV）所在的位置。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/h264_bitstream_macro_diagram.png" alt="h264 比特流宏观图" title="h264 比特流宏观图"></p>
<p>我们可以探究其它比特流，如 <a target="_blank" rel="noopener" href="https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.6-20160331-draft.pdf">VP9 比特流</a>，<a target="_blank" rel="noopener" href="http://handle.itu.int/11.1002/1000/11885-en?locatt=format:pdf">H.265（HEVC）</a>或是我们的新朋友 <a target="_blank" rel="noopener" href="https://medium.com/@mbebenita/av1-bitstream-analyzer-d25f1c27072b#.d5a89oxz8">AV1 比特流</a>，<a target="_blank" rel="noopener" href="http://www.gpac-licensing.com/2016/07/12/vp9-av1-bitstream-format/">他们很相似吗？不</a>，但只要学习了其中之一，学习其他的就简单多了。</p>
<blockquote>
<h3 id="自己动手：检查-h-264-比特流">自己动手：检查 H.264 比特流</h3>
<p>我们可以<a target="_blank" rel="noopener" href="https://github.com/leandromoreira/introduction_video_technology/blob/master/encoding_pratical_examples.md#generate-a-single-frame-video">生成一个单帧视频</a>，使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MediaInfo">mediainfo</a> 检查它的 H.264 比特流。事实上，你甚至可以查看<a target="_blank" rel="noopener" href="https://github.com/MediaArea/MediaInfoLib/blob/master/Source/MediaInfo/Video/File_Avc.cpp">解析 h264(AVC) 视频流的源代码</a>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/mediainfo_details_1.png" alt="mediainfo h264 比特流的详情 " title="mediainfo h264 比特流的详情"></p>
<p>我们也可使用 <a target="_blank" rel="noopener" href="https://software.intel.com/en-us/intel-video-pro-analyzer">Intel® Video Pro Analyzer</a>，需要付费，但也有只能查看前 10 帧的免费试用版，这已经够达成学习目的了。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/intel-video-pro-analyzer.png" alt="Intel® Video Pro Analyzer h264 比特流的详情" title="Intel® Video Pro Analyzer h264 比特流的详情"></p>
</blockquote>
<blockquote>
<h3 id="关于h264-我们还需要了解什么？">关于H264，我们还需要了解什么？</h3>
<p>除了如上对H264码流的介绍外，H264还有很多其他的内容需要了解，例如：X264和H264之间的关系是什么？H264未来会被其他的新型编解码器所代替吗？……关于这些信息可以参考：<a target="_blank" rel="noopener" href="https://www.videoproc.com/resource/h264-codec.htm">https://www.videoproc.com/resource/h264-codec.htm</a>。</p>
</blockquote>
<h2 id="回顾">回顾</h2>
<p>我们可以看到我们学了许多<strong>使用相同模型的现代编解码器</strong>。事实上，让我们看看 Thor 视频编解码器框图，它包含所有我们学过的步骤。你现在应该能更好地理解数字视频领域内的创新和论文。<br>
<img src="/2020/02/28/Introduction-to-digital-video-technology/thor_codec_block_diagram.png" alt="thor 编解码器块图" title="thor 编解码器块图"></p>
<p>之前我们计算过我们<a href="#%E8%89%B2%E5%BA%A6%E5%AD%90%E9%87%87%E6%A0%B7">需要 139GB 来保存一个一小时，720p 分辨率和30fps的视频文件</a>，如果我们使用在这里学过的技术，如<strong>帧间和帧内预测，转换，量化，熵编码和其它</strong>我们能实现——假设我们<strong>每像素花费 0.031 bit</strong>——同样观感质量的视频，<strong>对比 139GB 的存储，只需 367.82MB</strong>。</p>
<blockquote>
<p>我们根据这里提供的示例视频选择<strong>每像素使用 0.031 bit</strong>。</p>
</blockquote>
<h2 id="h-265-如何实现比-h-264-更好的压缩率">H.265 如何实现比 H.264 更好的压缩率</h2>
<p>我们已经更多地了解了编解码器的工作原理，那么就容易理解新的编解码器如何使用更少的数据量传输更高分辨率的视频。</p>
<p>我们将比较 AVC 和 HEVC，要记住的是：我们几乎总是要在压缩率和更多的 CPU 周期（复杂度）之间作权衡。</p>
<p>HEVC 比 AVC 有更大和更多的<strong>分区</strong>（和<strong>子分区</strong>）选项，更多<strong>帧内预测方向</strong>，<strong>改进的熵编码</strong>等，所有这些改进使得 H.265 比 H.264 的压缩率提升 50%。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/avc_vs_hevc.png" alt="h264 vs h265" title="H.264 vs H.265"></p>
<h1>在线流媒体</h1>
<h2 id="通用架构">通用架构</h2>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/general_architecture.png" alt="general_architecture"></p>
<p>[TODO]</p>
<h2 id="渐进式下载和自适应流">渐进式下载和自适应流</h2>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/progressive_download.png" alt="progressive_download"></p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/adaptive_streaming.png" alt="adaptive_streaming"></p>
<p>[TODO]</p>
<h2 id="内容保护">内容保护</h2>
<p>我们可以用一个简单的令牌认证系统来保护视频。用户需要拥有一个有效的令牌才可以播放视频，CDN 会拒绝没有令牌的用户的请求。它与大多数网站的身份认证系统非常相似。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/token_protection.png" alt="token_protection"></p>
<p>仅仅使用令牌认证系统，用户仍然可以下载并重新分发视频。DRM 系统可以用来避免这种情况。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/drm.png" alt="drm"></p>
<p>实际情况下，人们通常同时使用这两种技术提供授权和认证。</p>
<h3 id="drm">DRM</h3>
<h4 id="主要系统">主要系统</h4>
<ul>
<li>FPS - <a target="_blank" rel="noopener" href="https://developer.apple.com/streaming/fps/"><strong>FairPlay Streaming</strong></a></li>
<li>PR - <a target="_blank" rel="noopener" href="https://www.microsoft.com/playready/"><strong>PlayReady</strong></a></li>
<li>WV - <a target="_blank" rel="noopener" href="http://www.widevine.com/"><strong>Widevine</strong></a></li>
</ul>
<h4 id="是什么">是什么</h4>
<p>DRM 指的是数字版权管理，是一种<strong>为数字媒体提供版权保护</strong>的方法，例如数字视频和音频。尽管用在了很多场合，但它并<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Digital_rights_management#DRM-free_works">没有被普遍接受</a>.</p>
<h4 id="为什么">为什么</h4>
<p>内容的创作者（大多是工作室/制片厂）希望保护他们的知识产权，使他们的数字媒体免遭未经授权的分发。</p>
<h4 id="怎么做">怎么做</h4>
<p>我们将用一种简单的、抽象的方式描述 DRM</p>
<p>现有一份<strong>内容 C1</strong>（如 HLS 或 DASH 视频流），一个<strong>播放器 P1</strong>（如 shaka-clappr, exo-player 或 iOS），装在<strong>设备 D1</strong>（如智能手机、电视或台式机/笔记本）上，使用 <strong>DRM 系统 DRM1</strong>（如 FairPlay Streaming, PlayReady, Widevine）</p>
<p>内容 C1 由 DRM1 用一个<strong>对称密钥 K1</strong> 加密，生成<strong>加密内容 C’1</strong></p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/drm_general_flow.jpeg" alt="DRM 一般流程" title="DRM 一般流程"></p>
<p>设备 D1 上的播放器 P1 有一个非对称密钥对，密钥对包含一个<strong>私钥 PRK1</strong>（这个密钥是受保护的<sup>1</sup>，只有 <strong>D1</strong> 知道密钥内容），和一个<strong>公钥 PUK1</strong></p>
<blockquote>
<p><strong><sup>1</sup>受保护的</strong>: 这种保护可以<strong>通过硬件</strong>进行保护，例如, 将这个密钥存储在一个特殊的芯片（只读）中，芯片的工作方式就像一个用来解密的[黑箱]。 或<strong>通过软件</strong>进行保护（较低的安全系数）。DRM 系统提供了识别设备所使用的保护类型的方法。</p>
</blockquote>
<p>当 <strong>播放器 P1 希望播放****加密内容 C’1</strong> 时，它需要与 <strong>DRM1</strong> 协商，将公钥 <strong>PUK1</strong> 发送给 DRM1, DRM1 会返回一个被公钥 <strong>PUK1</strong> <strong>加密过的 K1</strong>。按照推论，结果就是<strong>只有 D1 能够解密</strong>。</p>
<p><code>K1P1D1 = enc(K1, PUK1)</code></p>
<p><strong>P1</strong> 使用它的本地 DRM 系统（这可以使用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%8A%AF%E7%89%87">SoC</a> ，一个专门的硬件和软件，这个系统可以使用它的私钥 PRK1 用来<strong>解密</strong>内容，它可以解密被加密过的<strong>K1P1D1 的对称密钥 K1</strong>。理想情况下，密钥不会被导出到内存以外的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">K1 &#x3D; dec(K1P1D1, PRK1)</span><br><span class="line"></span><br><span class="line">P1.play(dec(C&#39;1, K1))</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/drm_decoder_flow.jpeg" alt="DRM 解码流程" title="DRM 解码流程"></p>
<h1>如何使用 jupyter</h1>
<p>确保你已安装 docker，只需运行 <code>./s/start_jupyter.sh</code>，然后按照控制台的说明进行操作。</p>
<h1>会议</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://demuxed.com/">DEMUXED</a> - 您可以<a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCIc_DkRxo9UgUSTvWVNCmpA">查看最近的2个活动演示</a>。</li>
</ul>
<h1>参考</h1>
<p>这里有最丰富的资源，这篇文档包含的信息，均摘录、依据或受它们启发。你可以用这些精彩的链接，书籍，视频等深化你的知识。</p>
<p>在线课程和教程：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.coursera.org/learn/digital/">https://www.coursera.org/learn/digital/</a></li>
<li><a target="_blank" rel="noopener" href="https://people.xiph.org/~tterribe/pubs/lca2012/auckland/intro_to_video1.pdf">https://people.xiph.org/~tterribe/pubs/lca2012/auckland/intro_to_video1.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://xiph.org/video/vid1.shtml">https://xiph.org/video/vid1.shtml</a></li>
<li><a target="_blank" rel="noopener" href="https://xiph.org/video/vid2.shtml">https://xiph.org/video/vid2.shtml</a></li>
<li><a target="_blank" rel="noopener" href="http://slhck.info/ffmpeg-encoding-course">http://slhck.info/ffmpeg-encoding-course</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cambridgeincolour.com/tutorials/camera-sensors.htm">http://www.cambridgeincolour.com/tutorials/camera-sensors.htm</a></li>
<li><a target="_blank" rel="noopener" href="http://www.slideshare.net/vcodex/a-short-history-of-video-coding">http://www.slideshare.net/vcodex/a-short-history-of-video-coding</a></li>
<li><a target="_blank" rel="noopener" href="http://www.slideshare.net/vcodex/introduction-to-video-compression-13394338">http://www.slideshare.net/vcodex/introduction-to-video-compression-1339433</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/media/media-formats.html">https://developer.android.com/guide/topics/media/media-formats.html</a></li>
<li><a target="_blank" rel="noopener" href="http://www.slideshare.net/MadhawaKasun/audio-compression-23398426">http://www.slideshare.net/MadhawaKasun/audio-compression-23398426</a></li>
<li><a target="_blank" rel="noopener" href="http://inst.eecs.berkeley.edu/~ee290t/sp04/lectures/02-Motion_Compensation_girod.pdf">http://inst.eecs.berkeley.edu/~ee290t/sp04/lectures/02-Motion_Compensation_girod.pdf</a></li>
</ul>
<p>书籍:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1486395327&amp;sr=1-1">https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1486395327&amp;sr=1-1</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/H-264-Advanced-Video-Compression-Standard/dp/0470516925">https://www.amazon.com/H-264-Advanced-Video-Compression-Standard/dp/0470516925</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Practical-Guide-Video-Audio-Compression/dp/0240806301/ref=sr_1_3?s=books&amp;ie=UTF8&amp;qid=1486396914&amp;sr=1-3&amp;keywords=A+PRACTICAL+GUIDE+TO+VIDEO+AUDIO">https://www.amazon.com/Practical-Guide-Video-Audio-Compression/dp/0240806301/ref=sr_1_3?s=books&amp;ie=UTF8&amp;qid=1486396914&amp;sr=1-3&amp;keywords=A+PRACTICAL+GUIDE+TO+VIDEO+AUDIO</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Video-Encoding-Numbers-Eliminate-Guesswork/dp/0998453005/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1486396940&amp;sr=1-1&amp;keywords=jan+ozer">https://www.amazon.com/Video-Encoding-Numbers-Eliminate-Guesswork/dp/0998453005/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1486396940&amp;sr=1-1&amp;keywords=jan+ozer</a></li>
</ul>
<p>比特流规范:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.itu.int/rec/T-REC-H.264-201610-I">http://www.itu.int/rec/T-REC-H.264-201610-I</a></li>
<li><a target="_blank" rel="noopener" href="http://www.itu.int/ITU-T/recommendations/rec.aspx?rec=12904&amp;lang=en">http://www.itu.int/ITU-T/recommendations/rec.aspx?rec=12904&amp;lang=en</a></li>
<li><a target="_blank" rel="noopener" href="https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.6-20160331-draft.pdf">https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.6-20160331-draft.pdf</a></li>
<li><a target="_blank" rel="noopener" href="http://iphome.hhi.de/wiegand/assets/pdfs/2012_12_IEEE-HEVC-Overview.pdf">http://iphome.hhi.de/wiegand/assets/pdfs/2012_12_IEEE-HEVC-Overview.pdf</a></li>
<li><a target="_blank" rel="noopener" href="http://phenix.int-evry.fr/jct/doc_end_user/current_document.php?id=7243">http://phenix.int-evry.fr/jct/doc_end_user/current_document.php?id=7243</a></li>
<li><a target="_blank" rel="noopener" href="http://gentlelogic.blogspot.com.br/2011/11/exploring-h264-part-2-h264-bitstream.html">http://gentlelogic.blogspot.com.br/2011/11/exploring-h264-part-2-h264-bitstream.html</a></li>
</ul>
<p>软件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ffmpeg.org/">https://ffmpeg.org/</a></li>
<li><a target="_blank" rel="noopener" href="https://ffmpeg.org/ffmpeg-all.html">https://ffmpeg.org/ffmpeg-all.html</a></li>
<li><a target="_blank" rel="noopener" href="https://ffmpeg.org/ffprobe.html">https://ffmpeg.org/ffprobe.html</a></li>
<li><a target="_blank" rel="noopener" href="https://trac.ffmpeg.org/wiki/">https://trac.ffmpeg.org/wiki/</a></li>
<li><a target="_blank" rel="noopener" href="https://software.intel.com/en-us/intel-video-pro-analyzer">https://software.intel.com/en-us/intel-video-pro-analyzer</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@mbebenita/av1-bitstream-analyzer-d25f1c27072b#.d5a89oxz8">https://medium.com/@mbebenita/av1-bitstream-analyzer-d25f1c27072b#.d5a89oxz8</a></li>
</ul>
<p>非-ITU 编解码器:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://aomedia.googlesource.com/">https://aomedia.googlesource.com/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/webmproject/libvpx/tree/master/vp9">https://github.com/webmproject/libvpx/tree/master/vp9</a></li>
<li><a target="_blank" rel="noopener" href="https://people.xiph.org/~xiphmont/demo/daala/demo1.shtml">https://people.xiph.org/~xiphmont/demo/daala/demo1.shtml</a></li>
<li><a target="_blank" rel="noopener" href="https://people.xiph.org/~jm/daala/revisiting/">https://people.xiph.org/~jm/daala/revisiting/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=lzPaldsmJbk">https://www.youtube.com/watch?v=lzPaldsmJbk</a></li>
<li><a target="_blank" rel="noopener" href="https://fosdem.org/2017/schedule/event/om_av1/">https://fosdem.org/2017/schedule/event/om_av1/</a></li>
</ul>
<p>编码概念:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://x265.org/hevc-h265/">http://x265.org/hevc-h265/</a></li>
<li><a target="_blank" rel="noopener" href="http://slhck.info/video/2017/03/01/rate-control.html">http://slhck.info/video/2017/03/01/rate-control.html</a></li>
<li><a target="_blank" rel="noopener" href="http://slhck.info/video/2017/02/24/vbr-settings.html">http://slhck.info/video/2017/02/24/vbr-settings.html</a></li>
<li><a target="_blank" rel="noopener" href="http://slhck.info/video/2017/02/24/crf-guide.html">http://slhck.info/video/2017/02/24/crf-guide.html</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1702.00817v1.pdf">https://arxiv.org/pdf/1702.00817v1.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://trac.ffmpeg.org/wiki/Debug/MacroblocksAndMotionVectors">https://trac.ffmpeg.org/wiki/Debug/MacroblocksAndMotionVectors</a></li>
<li><a target="_blank" rel="noopener" href="http://web.ece.ucdavis.edu/cerl/ReliableJPEG/Cung/jpeg.html">http://web.ece.ucdavis.edu/cerl/ReliableJPEG/Cung/jpeg.html</a></li>
<li><a target="_blank" rel="noopener" href="http://www.adobe.com/devnet/adobe-media-server/articles/h264_encoding.html">http://www.adobe.com/devnet/adobe-media-server/articles/h264_encoding.html</a></li>
<li><a target="_blank" rel="noopener" href="https://prezi.com/8m7thtvl4ywr/mp3-and-aac-explained/">https://prezi.com/8m7thtvl4ywr/mp3-and-aac-explained/</a></li>
</ul>
<p>测试用视频序列:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://bbb3d.renderfarming.net/download.html">http://bbb3d.renderfarming.net/download.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.its.bldrdoc.gov/vqeg/video-datasets-and-organizations.aspx">https://www.its.bldrdoc.gov/vqeg/video-datasets-and-organizations.aspx</a></li>
</ul>
<p>杂项:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://stackoverflow.com/a/24890903">http://stackoverflow.com/a/24890903</a></li>
<li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/38094302/how-to-understand-header-of-h264">http://stackoverflow.com/questions/38094302/how-to-understand-header-of-h264</a></li>
<li><a target="_blank" rel="noopener" href="http://techblog.netflix.com/2016/08/a-large-scale-comparison-of-x264-x265.html">http://techblog.netflix.com/2016/08/a-large-scale-comparison-of-x264-x265.html</a></li>
<li><a target="_blank" rel="noopener" href="http://vanseodesign.com/web-design/color-luminance/">http://vanseodesign.com/web-design/color-luminance/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.biologymad.com/nervoussystem/eyenotes.htm">http://www.biologymad.com/nervoussystem/eyenotes.htm</a></li>
<li><a target="_blank" rel="noopener" href="http://www.compression.ru/video/codec_comparison/h264_2012/mpeg4_avc_h264_video_codecs_comparison.pdf">http://www.compression.ru/video/codec_comparison/h264_2012/mpeg4_avc_h264_video_codecs_comparison.pdf</a></li>
<li><a target="_blank" rel="noopener" href="http://www.csc.villanova.edu/~rschumey/csc4800/dct.html">http://www.csc.villanova.edu/~rschumey/csc4800/dct.html</a></li>
<li><a target="_blank" rel="noopener" href="http://www.explainthatstuff.com/digitalcameras.html">http://www.explainthatstuff.com/digitalcameras.html</a></li>
<li><a target="_blank" rel="noopener" href="http://www.hkvstar.com">http://www.hkvstar.com</a></li>
<li><a target="_blank" rel="noopener" href="http://www.hometheatersound.com/">http://www.hometheatersound.com/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.lighterra.com/papers/videoencodingh264/">http://www.lighterra.com/papers/videoencodingh264/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.red.com/learn/red-101/video-chroma-subsampling">http://www.red.com/learn/red-101/video-chroma-subsampling</a></li>
<li><a target="_blank" rel="noopener" href="http://www.slideshare.net/ManoharKuse/hevc-intra-coding">http://www.slideshare.net/ManoharKuse/hevc-intra-coding</a></li>
<li><a target="_blank" rel="noopener" href="http://www.slideshare.net/mwalendo/h264vs-hevc">http://www.slideshare.net/mwalendo/h264vs-hevc</a></li>
<li><a target="_blank" rel="noopener" href="http://www.slideshare.net/rvarun7777/final-seminar-46117193">http://www.slideshare.net/rvarun7777/final-seminar-46117193</a></li>
<li><a target="_blank" rel="noopener" href="http://www.springer.com/cda/content/document/cda_downloaddocument/9783642147029-c1.pdf">http://www.springer.com/cda/content/document/cda_downloaddocument/9783642147029-c1.pdf</a></li>
<li><a target="_blank" rel="noopener" href="http://www.streamingmedia.com/Articles/Editorial/Featured-Articles/A-Progress-Report-The-Alliance-for-Open-Media-and-the-AV1-Codec-110383.aspx">http://www.streamingmedia.com/Articles/Editorial/Featured-Articles/A-Progress-Report-The-Alliance-for-Open-Media-and-the-AV1-Codec-110383.aspx</a></li>
<li><a target="_blank" rel="noopener" href="http://www.streamingmediaglobal.com/Articles/ReadArticle.aspx?ArticleID=116505&amp;PageNum=1">http://www.streamingmediaglobal.com/Articles/ReadArticle.aspx?ArticleID=116505&amp;PageNum=1</a></li>
<li><a target="_blank" rel="noopener" href="http://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit/">http://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit/</a></li>
<li><a target="_blank" rel="noopener" href="https://cardinalpeak.com/blog/the-h-264-sequence-parameter-set/">https://cardinalpeak.com/blog/the-h-264-sequence-parameter-set/</a></li>
<li><a target="_blank" rel="noopener" href="https://cardinalpeak.com/blog/worlds-smallest-h-264-encoder/">https://cardinalpeak.com/blog/worlds-smallest-h-264-encoder/</a></li>
<li><a target="_blank" rel="noopener" href="https://codesequoia.wordpress.com/category/video/">https://codesequoia.wordpress.com/category/video/</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/technotes/tn2224/_index.html">https://developer.apple.com/library/content/technotes/tn2224/_index.html</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/MeGUI/x264_Settings">https://en.wikibooks.org/wiki/MeGUI/x264_Settings</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming">https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/AOMedia_Video_1">https://en.wikipedia.org/wiki/AOMedia_Video_1</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Chroma_subsampling#/media/File:Colorcomp.jpg">https://en.wikipedia.org/wiki/Chroma_subsampling#/media/File:Colorcomp.jpg</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cone_cell">https://en.wikipedia.org/wiki/Cone_cell</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File:H.264_block_diagram_with_quality_score.jpg">https://en.wikipedia.org/wiki/File:H.264_block_diagram_with_quality_score.jpg</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inter_frame">https://en.wikipedia.org/wiki/Inter_frame</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intra-frame_coding">https://en.wikipedia.org/wiki/Intra-frame_coding</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Photoreceptor_cell">https://en.wikipedia.org/wiki/Photoreceptor_cell</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pixel_aspect_ratio">https://en.wikipedia.org/wiki/Pixel_aspect_ratio</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Presentation_timestamp">https://en.wikipedia.org/wiki/Presentation_timestamp</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rod_cell">https://en.wikipedia.org/wiki/Rod_cell</a></li>
<li><a target="_blank" rel="noopener" href="https://it.wikipedia.org/wiki/File:Pixel_geometry_01_Pengo.jpg">https://it.wikipedia.org/wiki/File:Pixel_geometry_01_Pengo.jpg</a></li>
<li><a target="_blank" rel="noopener" href="https://leandromoreira.com.br/2016/10/09/how-to-measure-video-quality-perception/">https://leandromoreira.com.br/2016/10/09/how-to-measure-video-quality-perception/</a></li>
<li><a target="_blank" rel="noopener" href="https://sites.google.com/site/linuxencoding/x264-ffmpeg-mapping">https://sites.google.com/site/linuxencoding/x264-ffmpeg-mapping</a></li>
<li><a target="_blank" rel="noopener" href="https://softwaredevelopmentperestroika.wordpress.com/2014/02/11/image-processing-with-python-numpy-scipy-image-convolution/">https://softwaredevelopmentperestroika.wordpress.com/2014/02/11/image-processing-with-python-numpy-scipy-image-convolution/</a></li>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/draft-fuldseth-netvc-thor-03">https://tools.ietf.org/html/draft-fuldseth-netvc-thor-03</a></li>
<li><a target="_blank" rel="noopener" href="https://www.encoding.com/android/">https://www.encoding.com/android/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.encoding.com/http-live-streaming-hls/">https://www.encoding.com/http-live-streaming-hls/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.iem.thm.de/telekom-labor/zinke/mk/mpeg2beg/whatisit.htm">https://www.iem.thm.de/telekom-labor/zinke/mk/mpeg2beg/whatisit.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lifewire.com/cmos-image-sensor-493271">https://www.lifewire.com/cmos-image-sensor-493271</a></li>
<li><a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/brief-history-video-codecs-yoav-nativ">https://www.linkedin.com/pulse/brief-history-video-codecs-yoav-nativ</a></li>
<li><a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/video-streaming-methodology-reema-majumdar">https://www.linkedin.com/pulse/video-streaming-methodology-reema-majumdar</a></li>
<li><a target="_blank" rel="noopener" href="https://www.vcodex.com/h264avc-intra-precition/">https://www.vcodex.com/h264avc-intra-precition/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=9vgtJJ2wwMA">https://www.youtube.com/watch?v=9vgtJJ2wwMA</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=LFXN9PiOGtY">https://www.youtube.com/watch?v=LFXN9PiOGtY</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Lto-ajuqW3w&amp;list=PLzH6n4zXuckpKAj1_88VS-8Z6yn9zX_P6">https://www.youtube.com/watch?v=Lto-ajuqW3w&amp;list=PLzH6n4zXuckpKAj1_88VS-8Z6yn9zX_P6</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=LWxu4rkZBLw">https://www.youtube.com/watch?v=LWxu4rkZBLw</a></li>
</ul>
<p>其他资源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.videoproc.com/resource/h264-codec.htm">https://www.videoproc.com/resource/h264-codec.htm</a></li>
</ul>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://wangwei1237.github.io/2020/02/28/Introduction-to-digital-video-technology/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E8%A7%86%E9%A2%91/" rel="tag">数字视频</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/03/03/digital-video-concept/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            数字视频基本概念
          
        </div>
      </a>
    
    
      <a href="/2020/02/25/how-to-calculate-the-MS-SSIM/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">如何计算MS-SSIM</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "ppRS6IT7xMHmCl54L7ynIC2Z-gzGzoHsz",
    app_key: "qEmM49ZlU6LOwXCHjzMUECKu",
    path: window.location.pathname,
    avatar: "mp",
    placeholder: "快来评论吧~",
    recordIP: true,
    visitor: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2024
        <i class="ri-heart-fill heart_icon"></i> wangwei
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <!--<span id="busuanzi_container_page_pv">本文阅读量<span id="busuanzi_value_page_pv_"></span>次</span>
  <span class="division">|</span>
  -->
  <span id="busuanzi_container_site_uv"><i class="ri-user-3-fill"></i>本站访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span id="busuanzi_container_site_pv"><i class="ri-eye-fill"></i>本站浏览次数:<span id="busuanzi_value_site_pv"></span></span>
</span>
<script>
  
</script>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="17哥"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/books">图书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/shares">分享</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/aboutme">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/weixin.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->
 
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
            <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css">
        
    
 
<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>