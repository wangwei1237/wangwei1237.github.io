<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>matplotlib的backends以及非交互式绘图</title>
    <url>/2020/04/28/Matplotlib-s-backends-and-non-interactive-backends-for-rendering/</url>
    <content><![CDATA[<p>在分析视频的psnr时，需要用到<code>matplotlib</code>来绘制视频每一帧的psnr。在Mac调试的时候可以正常生成如下所示的psnr趋势图：</p>
<p><img src="/2020/04/28/Matplotlib-s-backends-and-non-interactive-backends-for-rendering/1.png" alt></p>
<p>但是将应用部署到linux机器的时候，却提示<strong>ModuleNotFoundError: No module named ‘_tkinter’</strong>的错误。</p>
<a id="more"></a>

<p>具体如下图所示：</p>
<p><img src="/2020/04/28/Matplotlib-s-backends-and-non-interactive-backends-for-rendering/2.jpg" alt></p>
<p>请教了同事后采用如下的方式解决了问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib </span><br><span class="line">matplotlib.use(&#39;Agg&#39;)</span><br><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/Matplotlib-s-backends-and-non-interactive-backends-for-rendering/3.jpg" alt></p>
<p>虽然解决了问题，但是当时没有明白：</p>
<ul>
<li>问题究竟是如何解决的？</li>
<li>为什么这样就可以解决？</li>
<li>解决方案和之前的写法的差异在哪里？</li>
</ul>
<p>因此查阅了matplotlib的文档，然后就有了该文接下来的内容。为了保证材料的原汁原味，如下的内容均摘录自matplotlib的开发文档。</p>
<h2 id="matplotlib中backend的概念"><a href="#matplotlib中backend的概念" class="headerlink" title="matplotlib中backend的概念"></a>matplotlib中backend的概念</h2><p>A lot of documentation on the website and in the mailing lists refers to the <strong>“backend”</strong> and many new users are confused by this term. matplotlib targets many different use cases and output formats. Some people use matplotlib interactively from the python shell and have plotting windows pop up when they type commands. Some people run Jupyter notebooks and draw inline plots for quick data analysis. Others embed matplotlib into graphical user interfaces like wxpython or pygtk to build rich applications. Some people use matplotlib in batch scripts to generate postscript images from numerical simulations, and still others run web application servers to dynamically serve up graphs.</p>
<p><strong>To support all of these use cases, matplotlib can target different outputs, and each of these capabilities is called a backend; the “frontend” is the user facing code, i.e., the plotting code, whereas the “backend” does all the hard work behind-the-scenes to make the figure.</strong> </p>
<p>There are two types of backends: </p>
<ul>
<li>user interface backends (for use in pygtk, wxpython, tkinter, qt4, or macosx; also referred to as <code>&quot;interactive backends&quot;</code>). The interactive backends: GTK3Agg, GTK3Cairo, MacOSX, nbAgg, Qt4Agg, Qt4Cairo, Qt5Agg, Qt5Cairo, TkAgg, TkCairo, WebAgg, WX, WXAgg, WXCairo.</li>
<li>hardcopy backends to make image files (PNG, SVG, PDF, PS; also referred to as <code>&quot;non-interactive backends&quot;</code>). The non-interactive backends: agg, cairo, pdf, pgf, ps, svg, template.</li>
</ul>
<h2 id="matplotlib中backend的默认配置"><a href="#matplotlib中backend的默认配置" class="headerlink" title="matplotlib中backend的默认配置"></a>matplotlib中backend的默认配置</h2><p>By default, <strong>Matplotlib should automatically select a default backend which allows both interactive work and plotting from scripts</strong>, with output to the screen and/or to a file, so at least initially you will not need to worry about the backend. <strong>The most common exception is if your Python distribution comes without tkinter and you have no other GUI toolkit installed; this happens on certain Linux distributions</strong>, where you need to install a Linux package named python-tk (or similar).</p>
<p>If, however, you want to write graphical user interfaces, or a web application server, or need a better understanding of what is going on, read on. To make things a little more customizable for graphical user interfaces, matplotlib separates the concept of the renderer (the thing that actually does the drawing) from the canvas (the place where the drawing goes). The canonical renderer for user interfaces is Agg which uses the Anti-Grain Geometry C++ library to make a raster (pixel) image of the figure; it is used by the Qt5Agg, Qt4Agg, GTK3Agg, wxAgg, TkAgg, and macosx backends. An alternative renderer is based on the Cairo library, used by Qt5Cairo, Qt4Cairo, etc.</p>
<h2 id="interactive模式的概念"><a href="#interactive模式的概念" class="headerlink" title="interactive模式的概念"></a>interactive模式的概念</h2><p>Use of an interactive backend (see What is a backend?) permits–but does not by itself require or ensure–plotting to the screen. Whether and when plotting to the screen occurs, and whether a script or shell session continues after a plot is drawn on the screen, depends on the functions and methods that are called, and on a state variable that determines whether matplotlib is in “interactive mode”. The default Boolean value is set by the matplotlibrc file, and may be customized like any other configuration parameter (see Customizing Matplotlib with style sheets and rcParams). It may also be set via matplotlib.interactive(), and its value may be queried via matplotlib.is_interactive(). Turning interactive mode on and off in the middle of a stream of plotting commands, whether in a script or in a shell, is rarely needed and potentially confusing, so in the following we will assume all plotting is done with interactive mode either on or off.</p>
<p>Interactive mode may also be turned on via matplotlib.pyplot.ion(), and turned off via matplotlib.pyplot.ioff().</p>
<p><strong>In interactive mode, pyplot functions automatically draw to the screen.</strong> When plotting interactively, if using object method calls in addition to pyplot functions, then call draw() whenever you want to refresh the plot.</p>
<p>Use non-interactive mode in scripts in which you want to generate one or more figures and display them before ending or generating a new set of figures. In that case, use show() to display the figure(s) and to block execution until you have manually destroyed them.</p>
<h2 id="如何选择backend"><a href="#如何选择backend" class="headerlink" title="如何选择backend"></a>如何选择backend</h2><p>There are three ways to configure your backend:</p>
<ul>
<li>The <code>rcParams[&quot;backend&quot;]</code> (default: ‘agg’) parameter in your matplotlibrc file</li>
<li>The <code>MPLBACKEND</code> environment variable</li>
<li>The function <code>matplotlib.use()</code></li>
</ul>
<p>A more detailed description is given below.</p>
<p>If multiple of these are configurations are present, the last one from the list takes precedence; e.g. calling <code>matplotlib.use()</code> will override the setting in your matplotlibrc.</p>
<p>If no backend is explicitly set, Matplotlib automatically detects a usable backend based on what is available on your system and on whether a GUI event loop is already running. On Linux, if the environment variable <code>DISPLAY</code> is unset, the “event loop” is identified as “headless”, which causes a fallback to a noninteractive backend (agg).</p>
<p>Here is a detailed description of the configuration methods:</p>
<ol>
<li><p>Setting <code>rcParams[&quot;backend&quot;]</code> (default: ‘agg’) in your matplotlibrc file:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">backend : qt5agg   # use pyqt5 with antigrain (agg) rendering</span><br></pre></td></tr></table></figure>
<p>See also Customizing Matplotlib with style sheets and rcParams.</p>
</li>
<li><p>Setting the <code>MPLBACKEND</code> environment variable:</p>
<p>You can set the environment variable either for your current shell or for a single script.</p>
<p>On Unix:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; export MPLBACKEND&#x3D;qt5agg</span><br><span class="line">&gt; python simple_plot.py</span><br><span class="line"></span><br><span class="line">&gt; MPLBACKEND&#x3D;qt5agg python simple_plot.py</span><br></pre></td></tr></table></figure>

<p>On Windows, only the former is possible:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set MPLBACKEND&#x3D;qt5agg</span><br><span class="line">&gt; python simple_plot.py</span><br></pre></td></tr></table></figure>

<p>Setting this environment variable will override the backend parameter in any matplotlibrc, even if there is a matplotlibrc in your current working directory. Therefore, setting MPLBACKEND globally, e.g. in your .bashrc or .profile, is discouraged as it might lead to counter-intuitive behavior.</p>
</li>
<li><p>If your script depends on a specific backend you can use the function <code>matplotlib.use()</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib</span><br><span class="line">matplotlib.use(&#39;qt5agg&#39;)</span><br></pre></td></tr></table></figure>
<p>This should be done before any figure is created; otherwise Matplotlib may fail to switch the backend and raise an ImportError.</p>
<p>Using use will require changes in your code if users want to use a different backend. Therefore, you should avoid explicitly calling use unless absolutely necessary.</p>
</li>
</ol>
<h2 id="matplotlib-use-‘Agg’-的作用"><a href="#matplotlib-use-‘Agg’-的作用" class="headerlink" title="matplotlib.use(‘Agg’)的作用"></a>matplotlib.use(‘Agg’)的作用</h2><p>在介绍完整整体的matplotlib中的backends以及matplotlib中的绘图模式之后，就能明白为什么文章开始出现的迁移过程中会出现类似的错误。</p>
<p>首先根据<a href="#matplotlib中backend的默认配置">matplotlib中backend的默认配置</a>中的介绍可以知道，matplotlib会有一个默认的backend配置，并且该默认的backend会同时支持交互式绘图模式以及利用脚本绘图的模式。并且，交互式绘图还需要利用GUI工具来生成一个屏幕绘图的窗口。而迁移的Linux机器上缺乏tkinter这样的GUI工具，因此在<code>import matplotlib.pyplot as plt</code>的时候会产生错误。</p>
<p>而利用<code>matplotlib.use(&#39;Agg&#39;)</code>可以切换matplotlib的backend，将其backend从默认的交互式模式切换为非交互式模式，此时，生成的图形会以图片的形式保存起来，而无需tkinter这样的GUI工具的支持，因此可以解决本文最开始出现的问题。</p>
]]></content>
      <categories>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>non-interactive rendering</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Wireshark分析SRT直播流</title>
    <url>/2020/04/09/analysize-SRT-protocol-live-stream-with-wireshark/</url>
    <content><![CDATA[<p><a href="https://www.haivision.com/products/srt-secure-reliable-transport/" target="_blank" rel="noopener">SRT(Secure Reliable Transport)</a>是一种基于<a href="https://tools.ietf.org/html/draft-gg-udt-03" target="_blank" rel="noopener">UDT(UDP-based Data Transfer)</a>的、安全的、可靠的、开源的数据传输协议&amp;技术。SRT在UDP基础之上实现了：智能数据重传机制和AES256加密技术，这使得其成为一种安全、可靠、低延迟的传输技术。利用SRT，可以实现在不可预测的网络环境下（例如互联网）高效、安全的传输数据。<a href="https://github.com/Haivision/srt/" target="_blank" rel="noopener">SRT</a>还做了特殊优化以适合视频实时流数据的传输。根据<a href="https://www.srtalliance.org/srt-alliance-announces-the-addition-of-the-srt-low-latency-protocol-to-open-broadcaster-softwares-obs-studio/" target="_blank" rel="noopener">SRT Alliance</a>在2019-04-04的介绍，目前如下的应用已经集成并支持SRT：<a href="https://obsproject.com/" target="_blank" rel="noopener">OBS Studio</a>，<a href="https://www.videolan.org/vlc/" target="_blank" rel="noopener">VideoLAN’s VLC</a>，<a href="http://ffmpeg.org/" target="_blank" rel="noopener">FFMpeg</a>，<a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a>。</p>
<p><img src="/2020/04/09/analysize-SRT-protocol-live-stream-with-wireshark/1.png" alt></p>
<a id="more"></a>

<p>本文只介绍：<strong>如何利用FFMpeg生成SRT数据流并利用Wireshark对该SRT数据进行抓包分析</strong>。关于SRT的详细内容，可以参考<a href="https://github.com/Haivision/srt/files/2489142/SRT_Protocol_TechnicalOverview_DRAFT_2018-10-17.pdf" target="_blank" rel="noopener">SRT Protocol Technical Overview Draft</a>。</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol>
<li><p>按照<a href="https://github.com/Haivision/srt/blob/master/README.md" target="_blank" rel="noopener">说明</a>安装SRT</p>
</li>
<li><p>利用<code>./configure --enable-libsrt</code>重新编译FFMpeg，让ffmpeg工具集支持SRT协议。重新configure的过程如果遇到<code>ERROR: srt &gt;= 1.3.0 not found using pkg-config</code>的错误，可以查看<code>ffbuild/config.log</code>的相关信息，一般需要把srt和srt所依赖的openssl的<strong>pkgconfig</strong>路径增加到<code>PKG_CONFIG_PATH</code>环境变量中即可。</p>
</li>
<li><p>升级Wireshark到3.0之后的版本，并且设置Wireshark取消Wireshark对UDT协议的支持，具体做法为：点击菜单栏中的<code>Analyze</code>-&gt;<code>Enabled Protocols</code>，然后从弹出的支持协议中找到UDT，并取消UDT前面的选择标记。</p>
<p> <img src="/2020/04/09/analysize-SRT-protocol-live-stream-with-wireshark/2.jpg" alt></p>
</li>
<li><p>安装VLC播放器，用于播放SRT协议的视频流。</p>
</li>
</ol>
<h2 id="生成SRT直播流"><a href="#生成SRT直播流" class="headerlink" title="生成SRT直播流"></a>生成SRT直播流</h2><p>可以利用<code>ffmpeg</code>和<code>srt-live-transmit</code>（该工具在安装srt的时候会默认安装）来生成SRT直播流。主要思路是首先利用<code>ffmpeg</code>生成UDP的直播流，然后利用<code>srt-live-transmit</code>把UDP的直播流转换成SRT的直播流，更详细的方式可以参考<a href="https://github.com/Haivision/srt/blob/master/docs/srt-live-transmit.md" target="_blank" rel="noopener">srt-live-transmit的使用说明</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成UDP视频流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -f lavfi -re -i smptebars=duration=300:size=1280x720:rate=30 \</span></span><br><span class="line">-f lavfi -re -i sine=frequency=1000:duration=60:sample_rate=44100 \</span><br><span class="line">-pix_fmt yuv420p -c:v libx264 -b:v 1000k -g 30 -keyint_min 120 \</span><br><span class="line">-profile:v baseline -preset veryfast -f mpegts \</span><br><span class="line">"udp://127.0.0.1:5000?pkt_size=1316"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成SRT视频流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> srt-live-transmit -s:10 udp://:5000 srt://:5001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用ffplay播放SRT视频流</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffplay <span class="string">"srt://127.0.0.1:5001"</span></span></span><br></pre></td></tr></table></figure>

<p>具体播放效果如下所示：</p>
<p><img src="/2020/04/09/analysize-SRT-protocol-live-stream-with-wireshark/3.jpg" alt></p>
<h2 id="使用Wireshark分析SRT"><a href="#使用Wireshark分析SRT" class="headerlink" title="使用Wireshark分析SRT"></a>使用Wireshark分析SRT</h2><p>为了可以用Wireshark抓到SRT数据包，需要使用VLC播放器来打开刚才创建的SRT视频流，具体如下所示：</p>
<p><img src="/2020/04/09/analysize-SRT-protocol-live-stream-with-wireshark/4.jpg" alt></p>
<p>打开Wireshark，选择Lookback（因为要捕获的SRT地址为127.0.0.1），然后在捕获的数据窗口选择srt协议过滤，稍等片刻就可以看到捕获的SRT数据包，具体如下图所示：</p>
<p><img src="/2020/04/09/analysize-SRT-protocol-live-stream-with-wireshark/5.jpg" alt></p>
<p>接下来就可以利用Wireshark来分析SRT协议的处理流程，例如上图中的Handshake数据包。尤其是在学习的过程中，配合<a href="https://github.com/Haivision/srt/files/2489142/SRT_Protocol_TechnicalOverview_DRAFT_2018-10-17.pdf" target="_blank" rel="noopener">SRT的协议文档</a>以及Wireshark的抓包分析，能够加深对SRT协议的理解，达到事半功倍的效果。</p>
]]></content>
      <categories>
        <category>视频技术</category>
      </categories>
      <tags>
        <tag>Wireshark</tag>
        <tag>SRT</tag>
        <tag>网络协议分析</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS Catalina编译的FFMpeg运行crash</title>
    <url>/2020/04/08/ffmpeg-compiled-in-macOS-Catalina-runs-crash/</url>
    <content><![CDATA[<p>因为近期正在调研&amp;了解<a href="https://github.com/Haivision/srt" target="_blank" rel="noopener">SRT协议</a>的相关内容，为了方便，需要打开FFMpeg的<code>--enable-libsrt</code>功能并重新编译FFMpeg，从而保证FFMpeg支持SRT协议。但是重新编译之后却发现启动ffmpeg工具就会被内核杀死，具体如下所示。</p>
<p><img src="/2020/04/08/ffmpeg-compiled-in-macOS-Catalina-runs-crash/1.jpg" alt></p>
<a id="more"></a>

<p>利用<em>lldb</em>调试该<em>ffmpeg</em>发现直接提示<code>error: Malformed Mach-o file</code>的错误，具体如下：</p>
<p><img src="/2020/04/08/ffmpeg-compiled-in-macOS-Catalina-runs-crash/2.jpg" alt></p>
<p>编译异常的Mac版本和Xcode版本信息分别如下：</p>
<p><img src="/2020/04/08/ffmpeg-compiled-in-macOS-Catalina-runs-crash/3.jpg" alt></p>
<p>查阅了<a href="https://trac.ffmpeg.org/ticket/8073" target="_blank" rel="noopener">网上的资料</a>，也查看了<a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/ffmpeg.rb" target="_blank" rel="noopener">brew编译FFMpeg的指令</a>，原因可能是：<strong>Xcode11下clang默认开启-fstack-check</strong>。</p>
<p>同时，在如下图所示的Xcode 10.3版本的Mac上则可编译成功：</p>
<p><img src="/2020/04/08/ffmpeg-compiled-in-macOS-Catalina-runs-crash/4.jpg" alt></p>
<p>因此根据如上信息：<code>./configure</code>时需要增加<code>--host-cflags=-fno-stack-check</code>配置。</p>
<p>但是增加该配置之后，编译出的ffmpeg依然无法正常运行。</p>
<p><strong>暂时先将这个问题记录下来，等有时间了再彻底追查一下。</strong></p>
]]></content>
      <categories>
        <category>视频技术</category>
      </categories>
      <tags>
        <tag>FFMpeg</tag>
        <tag>编译</tag>
        <tag>macOS Catalina</tag>
      </tags>
  </entry>
  <entry>
    <title>Android环境下编译libyuv</title>
    <url>/2020/03/30/compile-libyuv-for-Android/</url>
    <content><![CDATA[<p>libyuv是Google开源的实现各种YUV格式与RGB格式之间相互转换、旋转、缩放的库。关于libyuv的具体介绍可以参考<a href="https://chromium.googlesource.com/libyuv/libyuv" target="_blank" rel="noopener">官网介绍</a>。</p>
<a id="more"></a>

<h2 id="Android-Studio编译libyuv"><a href="#Android-Studio编译libyuv" class="headerlink" title="Android Studio编译libyuv"></a>Android Studio编译libyuv</h2><p>在自己编译libyuv的过程中，遇到了很多坑。在解决这些坑的过程中发现，从网上查询的很多资料并没有对问题的解决提供帮助。因此，在自己趟过了所有的坑之后，就想把编译libyuv的过程整理了出来，一方面是做一个梳理和总结，另一方面也希望帮助更多有类似需求的人。</p>
<p>接下来，开始介绍在Android平台上，利用NKD编译包含libjpeg库的libyuv库。这个主要通过<a href="https://chromium.googlesource.com/libyuv/libyuv/+/refs/heads/master/Android.mk" target="_blank" rel="noopener">libyuv/Android.mk</a>中的如下代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_WHOLE_STATIC_LIBRARIES :&#x3D; libyuv_static</span><br><span class="line">LOCAL_MODULE :&#x3D; libyuv</span><br><span class="line">ifneq ($(LIBYUV_DISABLE_JPEG), &quot;yes&quot;)</span><br><span class="line">LOCAL_SHARED_LIBRARIES :&#x3D; jpeg</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>

<h2 id="需要下载的库"><a href="#需要下载的库" class="headerlink" title="需要下载的库"></a>需要下载的库</h2><ul>
<li><a href="https://chromium.googlesource.com/libyuv/libyuv" target="_blank" rel="noopener">libyuv</a>或者<a href="https//github.com/lemenkov/libyuv.git">libyuv</a></li>
<li><a href="https://github.com/libjpeg-turbo/libjpeg-turbo.git" target="_blank" rel="noopener">libjpeg-turbo</a></li>
</ul>
<h2 id="编译依赖"><a href="#编译依赖" class="headerlink" title="编译依赖"></a>编译依赖</h2><h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><p>因为NDK-r17之后的版本，不支持gcc编译so，需要使用clang来编译so库。因此编译时，需要确定好自己的NDK版本。</p>
<h3 id="CMAKE-NASM-GCC等"><a href="#CMAKE-NASM-GCC等" class="headerlink" title="CMAKE, NASM, GCC等"></a>CMAKE, NASM, GCC等</h3><p>该部分编译依赖为编译libjpeg-turbo库的编译依赖，具体可以参见libjpeg-turbo的<a href="https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/BUILDING.md" target="_blank" rel="noopener">BUILD.md</a></p>
<h2 id="编译libjpeg-turbo"><a href="#编译libjpeg-turbo" class="headerlink" title="编译libjpeg-turbo"></a>编译libjpeg-turbo</h2><ol>
<li><p>下载编译脚本，编译脚本位于<a href="https://github.com/wangwei1237/libyuv-with-jpeg/tree/master/libjpeg-turbo" target="_blank" rel="noopener">libjpeg-turbo</a>目录下，共计有三个脚本：</p>
<ol>
<li>config.sh：配置编译参数，例如ANDROID_NDK_ROOT等，需要根据自己的环境变量进行替换。</li>
<li>build_jpeg.sh：编译某个CPU架构的so库，该脚本中的变量一般不需要修改。</li>
<li>build_jpeg_all.sh：编译所有CPU架构的so库</li>
</ol>
</li>
<li><p>下载<a href="https://github.com/libjpeg-turbo/libjpeg-turbo" target="_blank" rel="noopener">libjpeg-turbo</a>源码：<code>git clone https://github.com/libjpeg-turbo/libjpeg-turbo.git</code>。</p>
</li>
<li><p>将第<em>1</em>步中下载到的三个文件复制到libjepg-turob源码的根目录下：<code>cp -r libjpeg-turbo/* JPEG_SRC_ROOT_PATH/</code>。</p>
</li>
<li><p>修改<em>config.sh</em>中的<code>ANDROID_NDK_ROOT</code>为自己的NDK路径，修改<code>ANDROID_NDK_VERSION</code>为对应的数字版本。例如<em>r16b</em>版本的为<code>ANDROID_NDK_VERSION=16</code>。</p>
</li>
<li><p>运行<code>sh build_jpeg_all.sh</code>编译libjpeg-turbo，运行之后会在当前目录的<em>libs</em>目录下生成各种CPU架构对应的so库。如下图所示：</p>
<p> <img src="/2020/03/30/compile-libyuv-for-Android/1.jpg" alt="图1. libjpeg-turbo编译产物"></p>
</li>
</ol>
<h2 id="编译libyuv"><a href="#编译libyuv" class="headerlink" title="编译libyuv"></a>编译libyuv</h2><ol>
<li><p>将之前下载的libyuv的源码导入到Android Studio中的指定目录：PROJECT/app/jni/libyuv,该目录自己定义就可以。</p>
</li>
<li><p>将上一步生成的so文件按照ABI的格式复制到libyuv/libs目录下，如下图所示：</p>
<p> <img src="/2020/03/30/compile-libyuv-for-Android/2.png" alt="图2"></p>
</li>
<li><p>修改libyuv目录下的Android.mk文件，<a href="https://github.com/wangwei1237/libyuv-with-jpeg/blob/master/myapp/jni/libyuv/Android.mk" target="_blank" rel="noopener">libyuv/Android.mk</a>文件中的第4~12行的内容即可。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">########################################################</span><br><span class="line">## &#123;&#123;BEGIN 增加如下的代码</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE :&#x3D; jpeg</span><br><span class="line">LOCAL_SRC_FILES :&#x3D; libs&#x2F;$(TARGET_ARCH_ABI)&#x2F;libjpeg.so</span><br><span class="line">LOCAL_EXPORT_C_INCLUDES :&#x3D; $(LOCAL_PATH)&#x2F;include</span><br><span class="line">include $(PREBUILT_SHARED_LIBRARY)</span><br><span class="line">## END&#125;&#125;</span><br><span class="line">########################################################</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照<a href="https://github.com/wangwei1237/libyuv-with-jpeg" target="_blank" rel="noopener">仓库</a>所示的<a href="https://github.com/wangwei1237/libyuv-with-jpeg/tree/master/myapp/jni" target="_blank" rel="noopener">myapp/jni</a>目录下的<em>Android.mk</em>和<em>Application.mk</em>文件修改自己代码中的对应文件即可，主要是用于编译libyuv使用。</p>
</li>
<li><p>修改自己app目录下的<a href="https://github.com/wangwei1237/libyuv-with-jpeg/blob/master/myapp/build.gradle" target="_blank" rel="noopener">build.gradle</a>，在android{}中增加如下编译任务</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    ndkBuild &#123;</span><br><span class="line">        path file(&#39;jni&#x2F;Android.mk&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>点击Android Studio的编译按钮编译即可，编译后生成的编译产物如下图所示：</p>
<p> <img src="/2020/03/30/compile-libyuv-for-Android/3.jpg" alt="图3. libyuv的编译产物"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>libyuv</tag>
      </tags>
  </entry>
  <entry>
    <title>图像金字塔简介</title>
    <url>/2020/03/18/introduction-to-image-pyramid/</url>
    <content><![CDATA[<h1 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h1><h2 id="图像金字塔的概念"><a href="#图像金字塔的概念" class="headerlink" title="图像金字塔的概念"></a>图像金字塔的概念</h2><p>一般而言，我们处理的图像通常是恒定大小（分辨率）的图像。但是在某些特殊的场景下，需要处理同一图像的不同分辨率的图像。例如，在图像中搜索某些内容时（例如面部），由于不确定待搜索的内容在图像中的区域大小，因此需要创建一个具有不同分辨率的图像集，并在该图像集的所有图像中执行搜索操作。</p>
<p>这些具有不同分辨率的图像集称为“图像金字塔”。之所以称其为“图像金字塔”，是因为当这些图像按照分辨率由低到高堆叠在一起时，底部的最大图像和顶部的最小图像看起来就像是一座金字塔。</p>
<a id="more"></a>

<p>因此，图像金字塔是图像的集合，这些图像集合由单个原始图像通过连续的降采样——直到达到某个期望的暂停点为止——产生。</p>
<p><img src="/2020/03/18/introduction-to-image-pyramid/1.jpg" alt></p>
<h2 id="图像金字塔的分类"><a href="#图像金字塔的分类" class="headerlink" title="图像金字塔的分类"></a>图像金字塔的分类</h2><p>应用中经常用到的图像金字塔主要有两种：</p>
<ul>
<li>高斯金字塔</li>
<li>拉普拉斯金字塔</li>
</ul>
<p>高斯金字塔一般用于图像的降采样，而拉普拉斯金字塔则用于通过图像金字塔中的低分辨率图像重构高分率图像的图像上采样。</p>
<h3 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h3><p>高斯金字塔中的低分辨率图像是通过删除高分辨率图像中的行和列而产生，具体如下所示：</p>
<ul>
<li>令高斯金字塔中第$i$层的图像为$G_i$</li>
<li>使用一个高斯核对$G_i$执行卷积操作得到$G_i^{\prime}$</li>
<li>然后删除$G_i^{\prime}$中的偶数行和偶数列，得到$G_{i+1}$</li>
</ul>
<p>根据如上的步骤，可以知道，第$i+1$级图像的分辨率是第$i$级图像的分辨率的$\frac{1}{4}$。</p>
<h4 id="pyrDown"><a href="#pyrDown" class="headerlink" title="pyrDown"></a>pyrDown</h4><p>在OpenCV中，可以使用<code>cv2.pyrDown()</code>生成图像的上一层级图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">higher_resolution = cv2.imread(<span class="string">'img.jpg'</span>)</span><br><span class="line">lower_resolution  = cv2.pyrDown(higher_resolution)</span><br></pre></td></tr></table></figure>

<p>下图是一个4级的高斯金字塔的例子。<br><img src="/2020/03/18/introduction-to-image-pyramid/2.jpg" alt></p>
<h4 id="pyrUp"><a href="#pyrUp" class="headerlink" title="pyrUp"></a>pyrUp</h4><p>我们还可以使用<code>cv2.pyrUp()</code>将图像转换为每个方向两倍大小的图像，该函数</p>
<ul>
<li>首先将图像的大小在各个维度上扩展2倍</li>
<li>然后对新增的行用0进行填充</li>
<li>最后再使用高斯滤波器执行卷积计算来获取“丢失”的像素的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">higher_resolution_2 = cv2.pyrUp(lower_resolution)</span><br></pre></td></tr></table></figure>

<p>从如上的步骤不难发现，<code>cv2.pyrUp()</code>并不是<code>cv2.pyrDown()</code>的逆运算，因为<code>cv2.pyrDown()</code>是一个丢失信息的操作，一旦分辨率降低，就会存在信息丢失。</p>
<p>因此，在示例代码中，<code>higher_resolution_2</code>和<code>higher_resolution</code>是不同的。</p>
<p>对<a href="#pyrDown">pyrDown</a>中的图像执行<code>pyrUp()</code>效果如下所示：<br><img src="/2020/03/18/introduction-to-image-pyramid/3.jpg" alt></p>
<h3 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h3><p>为了从图像金字塔中的低分辨率图像恢复高分辨率的图像，需要使用下采样过程中丢弃的信息。而这些数据则构成了拉普拉斯金字塔。</p>
<p>令$L_i$为高斯金字塔的第$i$级图像$G_i$下采样得到第$i+1$级图像$G_{i+1}$时丢失的信息，则：</p>
<p>$$L_i=G_i - cv2.pyrUp(G_{i+1})$$</p>
<p>$\{L_i | i \in 1…n\}$则构成拉普拉斯金字塔。</p>
<p>拉普拉斯金字塔由高斯金字塔而形成，并没有其它的额外功能，并且拉普拉斯金字塔图像和图像的边缘图像很像。在拉普拉斯金字塔中的图像的大多数元素为零。一个4级拉普拉斯金字塔的图像如下所示（已调整图像的曝光度以增强图像内容）：<br><img src="/2020/03/18/introduction-to-image-pyramid/4.jpg" alt></p>
<h2 id="尺度空间和图像金字塔卷积核的选择"><a href="#尺度空间和图像金字塔卷积核的选择" class="headerlink" title="尺度空间和图像金字塔卷积核的选择"></a>尺度空间和图像金字塔卷积核的选择</h2><p>在现实世界中，客观物体在不同尺度时有着不同的结构。这意味着，如果从不同的尺度去观察同一个物体，会得出不一样的结果。例如，从不同的距离观察同一个图像时，随着距离的不断缩小，能够观察到的图像的结构也有所不同。</p>
<p>观察一棵树的尺度和观察一片树叶的尺度也是不同的：观察一棵树的适当尺度应该是<strong>米</strong>，而观察一片叶子可能需要更细粒度的尺度才能得出较好的结果。</p>
<p>当计算机系统要对一个未知的场景进行分析时，并不能提前预知用什么样的尺度来描述图像信息中的<strong>interesting structures</strong>是最合适的。因此，唯一可行的方案就是将多个不同尺度的描述都考虑进来，以便捕获未知的尺度变化。</p>
<p>尺度空间理论和生物视觉之间也有着十分密切的联系。哺乳动物的视网膜以及视觉皮层第一阶段所记录的接受场的分布，与许多尺度空间操作都高度近似。</p>
<p>如<a href="#高斯金字塔">高斯金字塔</a>的描述，在生成高斯金字塔时，会采用高斯核(<em>filter</em>)对图像进行处理，那么为什么非要采用高斯核呢？</p>
<p>实际上，并非任何低通滤波器（<em>low-pass filter</em>）都可用于生成尺度空间。可用于生成尺度空间的filter必须满足如下的条件：</p>
<blockquote>
<p>由该平滑filter生成的粗尺度图像（高层图像）不会引入不存在于细尺度图像（低层图像）中的杂散结构。</p>
</blockquote>
<p>如上的条件的言外之意就是：给定粗尺度图像中的任何一个区域，细尺度图像上总能找到相应的区域。对这两个区域而言，粗尺度图像区域不能有新的结构。</p>
<p>受制于<a href="https://en.wikipedia.org/wiki/Scale-space_axioms" target="_blank" rel="noopener">尺度空间公理</a>，高斯卷积核是实现尺度变换的唯一线性核。因此，在图像金字塔中，需要采用高斯卷积核对图像进行处理。</p>
<p><a href="https://en.wikipedia.org/wiki/Scale-space_axioms" target="_blank" rel="noopener">尺度空间公理</a>需要满足如下的条件：</p>
<ul>
<li>线性</li>
<li>平移不变性</li>
<li>半群特性</li>
<li>旋转不变性</li>
<li>尺度不变性</li>
<li>正定性</li>
<li>正规性(积分为1)</li>
<li>不会引入新的极点</li>
<li>不会增强极点</li>
<li>存在无穷小的算子（可微性）</li>
</ul>
<h2 id="图像金字塔的应用"><a href="#图像金字塔的应用" class="headerlink" title="图像金字塔的应用"></a>图像金字塔的应用</h2><p>图像金字塔的一种应用是图像融合。例如，在图像拼接中会将两个图像堆叠，但是由于图像之间的不连续性，这种对原始图像的直接拼接的效果并不好。例如，我们对如下图所示的两幅图像：</p>
<p><img src="/2020/03/18/introduction-to-image-pyramid/5.jpg" alt></p>
<p>的直接拼接效果和采用图像金字塔拼接效果分别为（左图为直接拼接）：</p>
<p><img src="/2020/03/18/introduction-to-image-pyramid/8.jpg" alt></p>
<p>由此可以看出，使用“图像金字塔”融合图像则可以让拼接之后的图像看起来天衣无缝。</p>
<p>可以按照如下的步骤使用“图像金字塔”来拼接如上的图像（<a href="https://github.com/wangwei1237/wangwei1237.github.io/blob/master/2020/03/18/introduction-to-image-pyramid/image_pyramid_blend.ipynb" target="_blank" rel="noopener">玩转多尺度图像融合</a>)：</p>
<ol>
<li>加载图像</li>
<li>计算图像的高斯金字塔（在此示例中，级数为6）</li>
<li>从高斯金字塔中计算拉普拉斯金字塔</li>
<li>在每个拉普拉斯金字塔中加入苹果的左半部分和橙子的右半部分</li>
<li>最后，从联合图像金字塔中重建原始图像</li>
</ol>
<p>除了如上的<strong>多分辨率图像融合算法会用到图像金字塔</strong>之外，图像金字塔还可用于如下的场景：</p>
<ul>
<li>sift算法</li>
<li>在from coarse to fine由粗到精的搜索策略中都可以用金字塔</li>
<li>optical flow光流法</li>
<li>slam当中的姿态估计 </li>
<li>……</li>
</ul>
]]></content>
      <categories>
        <category>视觉技术</category>
      </categories>
      <tags>
        <tag>图像金字塔</tag>
        <tag>高斯金字塔</tag>
        <tag>拉普拉斯金字塔</tag>
        <tag>image pyramid</tag>
      </tags>
  </entry>
  <entry>
    <title>数字视频基本概念</title>
    <url>/2020/03/03/digital-video-concept/</url>
    <content><![CDATA[<p>在学习和研究视频技术的过程中，联合几个同事一起翻译了<a href="https://link.springer.com/book/10.1007/978-1-4302-6713-3" target="_blank" rel="noopener">Digital Video Concepts, Methods, and Metrics: Quality, Compression, Performance, and Power Trade-off Analysis</a>，形成了<a href="/digital-video-concept"><strong>数字视频概念，方法和测量指标：质量，压缩，性能和电量等的权衡分析（中文版）</strong></a>。该翻译版本仅供学习交流之用。希望对想学习和了解数字视频相关技术的同学，有所帮助。</p>
<p>在翻译的过程中，尽可能的保留了原书的内容，并且对原书中的个别内容进行了修正和补充。</p>
<a id="more"></a>

<p><img src="/digital-video-concept/images/cover_0.jpg" alt></p>
<p>该书在翻译的过程中采用gitbook方式编写，可以利用gitbook将该项目打包成静态网页格式或者PDF<br>格式，具体可以参见：<a href="https://einverne.github.io/gitbook-tutorial/output/static.html" target="_blank" rel="noopener">gitbook教程</a>。</p>
<p>项目主页地址：<a href="https://github.com/wangwei1237/digital_video_concepts.git" target="_blank" rel="noopener">github仓库</a></p>
<p>在线预览地址：<a href="https://wangwei1237.github.io/digital-video-concept">预览地址1</a>, <a href="https://wangwei1237.gitbook.io/digital_video_concepts" target="_blank" rel="noopener">预览地址2</a></p>
<p>在阅读过程中有任何意见或建议，欢迎在github上提交issue，我们也会快速跟进。</p>
]]></content>
      <categories>
        <category>视频技术</category>
      </categories>
      <tags>
        <tag>数字视频</tag>
        <tag>digital video</tag>
        <tag>视频基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>数字视频技术导论</title>
    <url>/2020/02/28/Introduction-to-digital-video-technology/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为工作关系需要了解数字视频相关技术，在学习的过程中找到了这份托管在github上的<strong>数字视频导论</strong>的材料。</p>
<p>这份材料介绍了基本的数字视频相关技术，言简意赅但又不枯燥无味，即有理论又有丰富的实践操作，在我学习的所有材料中算是比较上乘的材料。</p>
<p>基于如上的原因，将该材料的相关内容转载到此处。大家可以直接访问该材料的github仓库<a href="https://github.com/leandromoreira/digital_video_introduction" target="_blank" rel="noopener"><strong>digital_video_introduction</strong></a>获取相关内容。如下的所有内容皆来自<a href="https://github.com/leandromoreira/digital_video_introduction" target="_blank" rel="noopener"><strong>digital_video_introduction</strong></a>，特此标注。</p>
<p><a href="https://img.shields.io/badge/license-BSD--3--Clause-blue.svg" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/license-BSD--3--Clause-blue.svg" alt="license"></a></p>
<a id="more"></a>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这是一份循序渐进的视频技术的介绍。尽管它面向的是软件开发人员/工程师，但我们希望<strong>对任何人而言</strong>，这份文档都能简单易学。这个点子产生于一个<a href="https://docs.google.com/presentation/d/17Z31kEkl_NGJ0M66reqr9_uTG6tI5EDDVXpdPKVuIrs/edit#slide=id.p" target="_blank" rel="noopener">视频技术新手小型研讨会</a>期间。</p>
<p>本文档旨在尽可能使用<strong>浅显的词语，丰富的图像和实际例子</strong>介绍数字视频概念，使这些知识能适用于各种场合。你可以随时反馈意见或建议，以改进这篇文档。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#介绍">介绍</a></li>
<li><a href="#目录">目录</a></li>
<li><a href="#基本术语">基本术语</a><ul>
<li><a href="#编码彩色图像的其它方法">编码彩色图像的其它方法</a></li>
<li><a href="#自己动手：玩转图像和颜色">自己动手：玩转图像和颜色</a></li>
<li><a href="#DVD-的-DAR-是-4-3">DVD 的 DAR 是 4:3</a></li>
<li><a href="#自己动手：检查视频属性">自己动手：检查视频属性</a></li>
</ul>
</li>
<li><a href="#消除冗余">消除冗余</a><ul>
<li><a href="#颜色，亮度和我们的眼睛">颜色，亮度和我们的眼睛</a><ul>
<li><a href="#颜色模型">颜色模型</a></li>
<li><a href="#YCbCr-和-RGB-之间的转换">YCbCr 和 RGB 之间的转换</a></li>
<li><a href="#色度子采样">色度子采样</a></li>
<li><a href="#自己动手：检查-YCbCr-直方图">自己动手：检查 YCbCr 直方图</a></li>
</ul>
</li>
<li><a href="#帧类型">帧类型</a><ul>
<li><a href="#I-帧（帧内编码，关键帧）">I 帧（内部，关键帧）</a></li>
<li><a href="#P-帧（预测）">P 帧（预测）</a><ul>
<li><a href="#自己动手：具有单个-I-帧的视频">自己动手：具有单个 I 帧的视频</a></li>
</ul>
</li>
<li><a href="#B-帧（双向预测）">B 帧（双向预测）</a><ul>
<li><a href="#自己动手：使用-B-帧比较视频">自己动手：使用 B 帧比较视频</a></li>
</ul>
</li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#时间冗余（帧间预测）">时间冗余（帧间预测）</a><ul>
<li><a href="#自己动手：查看运动向量">自己动手：查看运动向量</a></li>
</ul>
</li>
<li><a href="#空间冗余（帧内预测）">空间冗余（帧内预测）</a><ul>
<li><a href="#自己动手：查看帧内预测">自己动手：查看帧内预测</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#视频编解码器是如何工作的？">视频编解码器是如何工作的？</a><ul>
<li><a href="#是什么？为什么？怎么做？">是什么？为什么？怎么做？</a></li>
<li><a href="#历史">历史</a><ul>
<li><a href="#AV1-的诞生">AV1 的诞生</a></li>
</ul>
</li>
<li><a href="#通用编解码器">通用编解码器</a></li>
<li><a href="#第一步-图片分区">第一步 - 图片分区</a><ul>
<li><a href="#自己动手：查看分区">自己动手：查看分区</a></li>
</ul>
</li>
<li><a href="#第二步-预测">第二步 - 预测</a></li>
<li><a href="#第三步-转换">第三步 - 转换</a><ul>
<li><a href="#自己动手：丢弃不同的系数">自己动手：丢弃不同的系数</a></li>
</ul>
</li>
<li><a href="#第四步-量化">第四步 - 量化</a><ul>
<li><a href="#自己动手：量化">自己动手：量化</a></li>
</ul>
</li>
<li><a href="#第五步-熵编码">第五步 - 熵编码</a><ul>
<li><a href="#VLC-编码：">VLC 编码</a></li>
<li><a href="#算术编码">算术编码</a></li>
<li><a href="#自己动手：CABAC-vs-CAVLC">自己动手：CABAC vs CAVLC</a></li>
</ul>
</li>
<li><a href="#第六步-比特流格式">第六步 - 比特流格式</a><ul>
<li><a href="#H-264-比特流">H.264 比特流</a></li>
<li><a href="#自己动手：检查-H-264-比特流">自己动手：检查 H.264 比特流</a></li>
</ul>
</li>
<li><a href="#回顾">回顾</a></li>
<li><a href="#H-265-如何实现比-H-264-更好的压缩率">H.265 如何实现比 H.264 更好的压缩率?</a></li>
</ul>
</li>
<li><a href="#在线流媒体">在线流媒体</a><ul>
<li><a href="#通用架构">通用架构</a></li>
<li><a href="#渐进式下载和自适应流">渐进式下载和自适应流</a></li>
<li><a href="#内容保护">内容保护</a></li>
</ul>
</li>
<li><a href="#如何使用-jupyter">如何使用 jupyter</a></li>
<li><a href="#会议">会议</a></li>
<li><a href="#参考">参考</a></li>
</ul>
<h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><p>一个<strong>图像</strong>可以视作一个<strong>二维矩阵</strong>。如果将<strong>色彩</strong>考虑进来，我们可以做出推广：将这个图像视作一个<strong>三维矩阵</strong>——多出来的维度用于储存色彩信息。</p>
<p>如果我们选择三原色（红、绿、蓝）代表这些色彩，这就定义了三个平面：第一个是红色平面，第二个是绿色平面，最后一个是蓝色平面。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/image_3d_matrix_rgb.png" alt="an image is a 3d matrix RGB" title="An image is a 3D matrix"></p>
<p>我们把这个矩阵里的每一个点称为<strong>像素</strong>（图像元素）。像素的色彩由三原色的<strong>强度</strong>（通常用数值表示）表示。例如，一个<strong>红色像素</strong>是指强度为 0 的绿色，强度为 0 的蓝色和强度最大的红色。<strong>粉色像素</strong>可以通过三种颜色的组合表示。如果规定强度的取值范围是 0 到 255，<strong>红色 255、绿色 192、蓝色 203</strong> 则表示粉色。</p>
<blockquote>
<h3 id="编码彩色图像的其它方法"><a href="#编码彩色图像的其它方法" class="headerlink" title="编码彩色图像的其它方法"></a>编码彩色图像的其它方法</h3><p>还有许多其它模型也可以用来表示色彩，进而组成图像。例如，给每种颜色都标上序号（如下图），这样每个像素仅需一个字节就可以表示出来，而不是 RGB 模型通常所需的 3 个。在这样一个模型里我们可以用一个二维矩阵来代替三维矩阵去表示我们的色彩，这将节省存储空间，但色彩的数量将会受限。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/nes-color-palette.png" alt="NES palette" title="NES palette"></p>
</blockquote>
<p>例如以下几张图片。第一张包含所有颜色平面。剩下的分别是红、绿、蓝色平面（显示为灰调）（译注：颜色强度高的地方显示为亮色，强度低为暗色）。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/rgb_channels_intensity.png" alt="RGB channels intensity" title="RGB channels intensity"></p>
<p>我们可以看到，对于最终的成像，红色平面对强度的贡献更多（三个平面最亮的是红色平面），蓝色平面（最后一张图片）的贡献大多只在马里奥的眼睛和他衣服的一部分。所有颜色平面对马里奥的胡子（最暗的部分）均贡献较少。</p>
<p>存储颜色的强度，需要占用一定大小的数据空间，这个大小被称为颜色深度。假如每个颜色（平面）的强度占用 8 bit（取值范围为 0 到 255），那么颜色深度就是 24（8*3）bit，我们还可以推导出我们可以使用 2 的 24 次方种不同的颜色。</p>
<blockquote>
<p>很棒的学习材料：<a href="http://www.cambridgeincolour.com/tutorials/camera-sensors.htm" target="_blank" rel="noopener">现实世界的照片是如何拍摄成 0 和 1 的</a>。</p>
</blockquote>
<p>图片的另一个属性是<strong>分辨率</strong>，即一个平面内像素的数量。通常表示成宽<em>高，例如下面这张 *</em>4x4** 的图片。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/resolution.png" alt="image resolution" title="image resolution"></p>
<blockquote>
<h3 id="自己动手：玩转图像和颜色"><a href="#自己动手：玩转图像和颜色" class="headerlink" title="自己动手：玩转图像和颜色"></a>自己动手：玩转图像和颜色</h3><p>你可以使用 <a href="#如何使用-jupyter">jupyter</a>（python, numpy, matplotlib 等等）<a href="https://github.com/wangwei1237/wangwei1237.github.io/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/image_as_3d_array.ipynb" target="_blank" rel="noopener">玩转图像</a>。</p>
<p>你也可以学习<a href="https://github.com/wangwei1237/wangwei1237.github.io/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/filters_are_easy.ipynb" target="_blank" rel="noopener">图像滤镜（边缘检测，磨皮，模糊。。。）的原理</a>。</p>
</blockquote>
<p>图像或视频还有一个属性是宽高比，它简单地描述了图像或像素的宽度和高度之间的比例关系。</p>
<p>当人们说这个电影或照片是 16:9 时，通常是指显示宽高比（DAR），然而我们也可以有不同形状的单个像素，我们称为像素宽高比（PAR）。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/DAR.png" alt="display aspect ratio" title="display aspect ratio"></p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/PAR.png" alt="pixel aspect ratio" title="pixel aspect ratio"></p>
<blockquote>
<h2 id="DVD-的-DAR-是-4-3"><a href="#DVD-的-DAR-是-4-3" class="headerlink" title="DVD 的 DAR 是 4:3"></a>DVD 的 DAR 是 4:3</h2><p>虽然 DVD 的实际分辨率是 704x480，但它依然保持 4:3 的宽高比，因为它有一个 10:11（704x10／480x11）的 PAR。</p>
</blockquote>
<p>现在我们可以将<strong>视频</strong>定义为在<strong>单位时间</strong>内<strong>连续的 n 帧</strong>，这可以视作一个新的维度，n 即为帧率，若单位时间为秒，则等同于 FPS (每秒帧数 Frames Per Second)。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/video.png" alt="video" title="video"></p>
<p>播放一段视频每秒所需的数据量就是它的<strong>比特率</strong>（即常说的码率）。</p>
<blockquote>
<p>比特率 = 宽 * 高 * 颜色深度 * 帧每秒</p>
</blockquote>
<p>例如，一段每秒 30 帧，每像素 24 bits，分辨率是 480x240 的视频，如果我们不做任何压缩，它将需要 <strong>82,944,000 比特每秒</strong>或 82.944 Mbps (30x480x240x24)。</p>
<p>当<strong>比特率</strong>几乎恒定时称为恒定比特率（<strong>CBR</strong>）；但它也可以变化，称为可变比特率（<strong>VBR</strong>）。</p>
<blockquote>
<p>这个图形显示了一个受限的 VBR，当帧为黑色时不会花费太多的数据量。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/vbr.png" alt="constrained vbr" title="constrained vbr"></p>
</blockquote>
<p>在早期，工程师们想出了一项技术能将视频的感官帧率加倍而<strong>没有消耗额外带宽</strong>。这项技术被称为<strong>隔行扫描</strong>；总的来说，它在一个时间点发送一个画面——画面用于填充屏幕的一半，而下一个时间点发送的画面用于填充屏幕的另一半。</p>
<p>如今的屏幕渲染大多使用<strong>逐行扫描技术</strong>。这是一种显示、存储、传输运动图像的方法，每帧中的所有行都会被依次绘制。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/interlaced_vs_progressive.png" alt="interlaced vs progressive" title="interlaced vs progressive"></p>
<p>现在我们知道了数字化<strong>图像</strong>的原理；它的<strong>颜色</strong>的编排方式；给定<strong>帧率</strong>和<strong>分辨率</strong>时，展示一个视频需要花费多少<strong>比特率</strong>；它是恒定的（CBR）还是可变的（VBR）；还有很多其它内容，如隔行扫描和 PAR。</p>
<blockquote>
<h2 id="自己动手：检查视频属性"><a href="#自己动手：检查视频属性" class="headerlink" title="自己动手：检查视频属性"></a>自己动手：检查视频属性</h2><p>你可以<a href="https://github.com/leandromoreira/introduction_video_technology/blob/master/encoding_pratical_examples.md#inspect-stream" target="_blank" rel="noopener">使用 ffmpeg 或 mediainfo 检查大多数属性的解释</a>。</p>
</blockquote>
<h1 id="消除冗余"><a href="#消除冗余" class="headerlink" title="消除冗余"></a>消除冗余</h1><p>我们认识到，不对视频进行压缩是不行的；<strong>一个单独的一小时长的视频</strong>，分辨率为 720p 和 30fps 时将<strong>需要 278GB<sup>*</sup></strong>。仅仅使用无损数据压缩算法——如 DEFLATE（被PKZIP, Gzip, 和 PNG 使用）——也无法充分减少视频所需的带宽，我们需要找到其它压缩视频的方法。</p>
<blockquote>
<p><sup>*</sup>我们使用乘积得出这个数字 1280 x 720 x 24 x 30 x 3600 （宽，高，每像素比特数，fps 和秒数）</p>
</blockquote>
<p>为此，我们可以<strong>利用视觉特性</strong>：和区分颜色相比，我们区分亮度要更加敏锐。<strong>时间上的重复</strong>：一段视频包含很多只有一点小小改变的图像。<strong>图像内的重复</strong>：每一帧也包含很多颜色相同或相似的区域。</p>
<h2 id="颜色，亮度和我们的眼睛"><a href="#颜色，亮度和我们的眼睛" class="headerlink" title="颜色，亮度和我们的眼睛"></a>颜色，亮度和我们的眼睛</h2><p>我们的眼睛<a href="http://vanseodesign.com/web-design/color-luminance/" target="_blank" rel="noopener">对亮度比对颜色更敏感</a>，你可以看看下面的图片自己测试。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/luminance_vs_color.png" alt="luminance vs color" title="luminance vs color"></p>
<p>如果你看不出左图的<strong>方块 A 和方块 B</strong> 的颜色是<strong>相同的</strong>，那么好，是我们的大脑玩了一个小把戏，这让我们更多的去注意光与暗，而不是颜色。右边这里有一个使用同样颜色的连接器，那么我们（的大脑）就能轻易分辨出事实，它们是同样的颜色。</p>
<blockquote>
<p><strong>简单解释我们的眼睛工作的原理</strong></p>
<p><a href="http://www.biologymad.com/nervoussystem/eyenotes.htm" target="_blank" rel="noopener">眼睛是一个复杂的器官</a>，有许多部分组成，但我们最感兴趣的是视锥细胞和视杆细胞。眼睛有<a href="https://en.wikipedia.org/wiki/Photoreceptor_cell" target="_blank" rel="noopener">大约1.2亿个视杆细胞和6百万个视锥细胞</a>。</p>
<p><strong>简单来说</strong>，让我们把颜色和亮度放在眼睛的功能部位上。<a href="https://en.wikipedia.org/wiki/Rod_cell" target="_blank" rel="noopener">视杆细胞</a><strong>主要负责亮度</strong>，而<a href="https://en.wikipedia.org/wiki/Cone_cell" target="_blank" rel="noopener">视锥细胞</a><strong>负责颜色</strong>，有三种类型的视锥，每个都有不同的颜料，叫做：<a href="https://upload.wikimedia.org/wikipedia/commons/1/1e/Cones_SMJ2_E.svg" target="_blank" rel="noopener">S-视锥（蓝色），M-视锥（绿色）和L-视锥（红色）</a>。</p>
<p>既然我们的视杆细胞（亮度）比视锥细胞多很多，一个合理的推断是相比颜色，我们有更好的能力去区分黑暗和光亮。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/eyes.jpg" alt="eyes composition" title="eyes composition"></p>
</blockquote>
<p>一旦我们知道我们对<strong>亮度</strong>（图像中的亮度）更敏感，我们就可以利用它。</p>
<h3 id="颜色模型"><a href="#颜色模型" class="headerlink" title="颜色模型"></a>颜色模型</h3><p>我们最开始学习的<a href="#基本术语">彩色图像的原理</a>使用的是 <strong>RGB 模型</strong>，但也有其他模型。有一种模型将亮度（光亮）和色度（颜色）分离开，它被称为 <strong>YCbCr</strong><sup>*</sup>。</p>
<blockquote>
<p><sup>*</sup> 有很多种模型做同样的分离。</p>
</blockquote>
<p>这个颜色模型使用 <strong>Y</strong> 来表示亮度，还有两种颜色通道：Cb（蓝色色度） 和 Cr（红色色度）。YCbCr 可以由 RGB 转换得来，也可以转换回 RGB。使用这个模型我们可以创建拥有完整色彩的图像，如下图。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/ycbcr.png" alt="ycbcr 例子" title="ycbcr 例子"></p>
<h3 id="YCbCr-和-RGB-之间的转换"><a href="#YCbCr-和-RGB-之间的转换" class="headerlink" title="YCbCr 和 RGB 之间的转换"></a>YCbCr 和 RGB 之间的转换</h3><p>有人可能会问，在<strong>不使用绿色（色度）</strong>的情况下，我们如何表现出所有的色彩？</p>
<p>为了回答这个问题，我们将介绍从 RGB 到 YCbCr 的转换。我们将使用 <a href="https://en.wikipedia.org/wiki/ITU-R" target="_blank" rel="noopener">ITU-R 小组</a>*建议的<a href="https://en.wikipedia.org/wiki/Rec._601" target="_blank" rel="noopener">标准 BT.601</a> 中的系数。</p>
<p>第一步是计算亮度，我们将使用 ITU 建议的常量，并替换 RGB 值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y &#x3D; 0.299R + 0.587G + 0.114B</span><br></pre></td></tr></table></figure>

<p>一旦我们有了亮度后，我们就可以拆分颜色（蓝色色度和红色色度）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cb &#x3D; 0.564(B - Y)</span><br><span class="line">Cr &#x3D; 0.713(R - Y)</span><br></pre></td></tr></table></figure>

<p>并且我们也可以使用 YCbCr 转换回来，甚至得到绿色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R &#x3D; Y + 1.402Cr</span><br><span class="line">B &#x3D; Y + 1.772Cb</span><br><span class="line">G &#x3D; Y - 0.344Cb - 0.714Cr</span><br></pre></td></tr></table></figure>

<blockquote>
<p><sup>*</sup>组织和标准在数字视频领域中很常见，它们通常定义什么是标准，例如，<a href="https://en.wikipedia.org/wiki/Rec._2020" target="_blank" rel="noopener">什么是 4K？我们应该使用什么帧率？分辨率？颜色模型？</a></p>
</blockquote>
<p>通常，<strong>显示屏</strong>（监视器，电视机，屏幕等等）<strong>仅使用 RGB 模型</strong>，并以不同的方式来组织，看看下面这些放大效果：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/new_pixel_geometry.jpg" alt="pixel geometry" title="pixel geometry"></p>
<h3 id="色度子采样"><a href="#色度子采样" class="headerlink" title="色度子采样"></a>色度子采样</h3><p>一旦我们能从图像中分离出亮度和色度，我们就可以利用人类视觉系统对亮度比色度更敏感的特点，选择性地剔除信息。<strong>色度子采样</strong>是一种编码图像时，使<strong>色度分辨率低于亮度</strong>的技术。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/ycbcr_subsampling_resolution.png" alt="ycbcr 子采样分辨率" title="ycbcr 子采样分辨率"></p>
<p>我们应该减少多少色度分辨率呢？已经有一些模式定义了如何处理分辨率和合并（<code>最终的颜色 = Y + Cb + Cr</code>）。</p>
<p>这些模式称为子采样系统，并被表示为 3 部分的比率 - <code>a:x:y</code>，其定义了色度平面的分辨率，与亮度平面上的、分辨率为 <code>a x 2</code> 的小块之间的关系。</p>
<ul>
<li><code>a</code> 是水平采样参考 (通常是 4)，</li>
<li><code>x</code> 是第一行的色度样本数（相对于 a 的水平分辨率），</li>
<li><code>y</code> 是第二行的色度样本数。</li>
</ul>
<blockquote>
<p>存在的一个例外是 4:1:0，其在每个亮度平面分辨率为 4 x 4 的块内提供一个色度样本。</p>
</blockquote>
<p>现代编解码器中使用的常用方案是： 4:4:4 (没有子采样)**, 4:2:2, 4:1:1, 4:2:0, 4:1:0 and 3:1:1。</p>
<blockquote>
<p>YCbCr 4:2:0 合并</p>
<p>这是使用 YCbCr 4:2:0 合并的一个图像的一块，注意我们每像素只花费 12bit。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/ycbcr_420_merge.png" alt="YCbCr 4:2:0 合并" title="YCbCr 4:2:0 合并"></p>
</blockquote>
<p>下图是同一张图片使用几种主要的色度子采样技术进行编码，第一行图像是最终的 YCbCr，而最后一行图像展示了色度的分辨率。这么小的损失确实是一个伟大的胜利。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/chroma_subsampling_examples.jpg" alt="色度子采样例子" title="色度子采样例子"></p>
<p>前面我们计算过我们需要 <a href="#消除冗余">278GB 去存储一个一小时长，分辨率在720p和30fps的视频文件</a>。如果我们使用 <code>YCbCr 4:2:0</code> 我们能剪掉<code>一半的大小（139GB）</code><sup>*</sup>，但仍然不够理想。</p>
<blockquote>
<p><sup>*</sup> 我们通过将宽、高、颜色深度和 fps 相乘得出这个值。前面我们需要 24 bit，现在我们只需要 12 bit。</p>
</blockquote>
<blockquote>
<h3 id="自己动手：检查-YCbCr-直方图"><a href="#自己动手：检查-YCbCr-直方图" class="headerlink" title="自己动手：检查 YCbCr 直方图"></a>自己动手：检查 YCbCr 直方图</h3><p>你可以<a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#generates-yuv-histogram" target="_blank" rel="noopener">使用 ffmpeg 检查 YCbCr 直方图</a>。这个场景有更多的蓝色贡献，由<a href="https://en.wikipedia.org/wiki/Histogram" target="_blank" rel="noopener">直方图</a>显示。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/yuv_histogram.png" alt="ycbcr 颜色直方图" title="ycbcr 颜色直方图"></p>
</blockquote>
<h2 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h2><p>现在我们进一步消除<code>时间冗余</code>，但在这之前让我们来确定一些基本术语。假设我们一段 30fps 的影片，这是最开始的 4 帧。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_1.png" alt="球 1" title="球 1"> <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_2.png" alt="球 2" title="球 2"> <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_3.png" alt="球 3" title="球 3"><br><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_4.png" alt="球 4" title="球 4"></p>
<p>我们可以在帧内看到<strong>很多重复内容</strong>，如<strong>蓝色背景</strong>，从 0 帧到第 3 帧它都没有变化。为了解决这个问题，我们可以将它们<strong>抽象地分类</strong>为三种类型的帧。</p>
<h3 id="I-帧（帧内编码，关键帧）"><a href="#I-帧（帧内编码，关键帧）" class="headerlink" title="I 帧（帧内编码，关键帧）"></a>I 帧（帧内编码，关键帧）</h3><p>I 帧（可参考，关键帧，帧内编码）是一个<strong>自足的帧</strong>。它不依靠任何东西来渲染，I 帧与静态图片相似。第一帧通常是 I 帧，但我们将看到 I 帧被定期插入其它类型的帧之间。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_1.png" alt="球 1" title="球 1"></p>
<h3 id="P-帧（预测）"><a href="#P-帧（预测）" class="headerlink" title="P 帧（预测）"></a>P 帧（预测）</h3><p>P 帧利用了一个事实：当前的画面几乎总能<strong>使用之前的一帧进行渲染</strong>。例如，在第二帧，唯一的改变是球向前移动了。仅仅使用（第二帧）对前一帧的引用和差值，我们就能重建前一帧。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_1.png" alt="球 1" title="球 1"> &lt;-  <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_2_diff.png" alt="球 2" title="球 2"></p>
<blockquote>
<h4 id="自己动手：具有单个-I-帧的视频"><a href="#自己动手：具有单个-I-帧的视频" class="headerlink" title="自己动手：具有单个 I 帧的视频"></a>自己动手：具有单个 I 帧的视频</h4><p>既然 P 帧使用较少的数据，为什么我们不能用<a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#1-i-frame-and-the-rest-p-frames" target="_blank" rel="noopener">单个 I 帧和其余的 P 帧</a>来编码整个视频？</p>
<p>编码完这个视频之后，开始观看它，并<strong>快进到视频的末尾部分</strong>，你会注意到<strong>它需要花一些时间</strong>才真正跳转到这部分。这是因为 <strong>P 帧需要一个引用帧</strong>（比如 I 帧）才能渲染。</p>
<p>你可以做的另一个快速试验，是使用单个 I 帧编码视频，然后<a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#1-i-frames-per-second-vs-05-i-frames-per-second" target="_blank" rel="noopener">再次编码且每 2 秒插入一个 I 帧</a>，并<strong>比较成品的大小</strong>。</p>
</blockquote>
<h3 id="B-帧（双向预测）"><a href="#B-帧（双向预测）" class="headerlink" title="B 帧（双向预测）"></a>B 帧（双向预测）</h3><p>如何引用前面和后面的帧去做更好的压缩？！简单地说 B 帧就是这么做的。</p>
<p> <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_1.png" alt="球 1" title="球 1"> &lt;-  <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_2_diff.png" alt="球 2" title="球 2"> -&gt; <img src="/2020/02/28/Introduction-to-digital-video-technology/smw_background_ball_3.png" alt="球 3" title="球 3"></p>
<blockquote>
<h4 id="自己动手：使用-B-帧比较视频"><a href="#自己动手：使用-B-帧比较视频" class="headerlink" title="自己动手：使用 B 帧比较视频"></a>自己动手：使用 B 帧比较视频</h4><p>你可以生成两个版本，一个使用 B 帧，另一个<a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#no-b-frames-at-all" target="_blank" rel="noopener">全部不使用 B 帧</a>，然后查看文件的大小以及画质。</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这些帧类型用于提供更好的压缩率，我们将在下一章看到这是如何发生的。现在，我们可以想到 I 帧是昂贵的，P 帧是便宜的，最便宜的是 B 帧。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/frame_types.png" alt="帧类型例子" title="帧类型例子"></p>
<h2 id="时间冗余（帧间预测）"><a href="#时间冗余（帧间预测）" class="headerlink" title="时间冗余（帧间预测）"></a>时间冗余（帧间预测）</h2><p>让我们探究去除<strong>时间上的重复</strong>，去除这一类冗余的技术就是<strong>帧间预测</strong>。</p>
<p>我们将尝试<strong>花费较少的数据量</strong>去编码在时间上连续的 0 号帧和 1 号帧。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/original_frames.png" alt="原始帧" title="原始帧"></p>
<p>我们可以做个减法，我们简单地<strong>用 0 号帧减去 1 号帧</strong>，得到残差，这样我们就只需要<strong>对残差进行编码</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/difference_frames.png" alt="残差帧" title="残差帧"></p>
<p>但我们有一个<strong>更好的方法</strong>来节省数据量。首先，我们将<code>0 号帧</code> 视为一个个分块的集合，然后我们将尝试将 <code>帧 1</code> 和 <code>帧 0</code> 上的块相匹配。我们可以将这看作是<strong>运动预测</strong>。</p>
<blockquote>
<h3 id="维基百科—块运动补偿"><a href="#维基百科—块运动补偿" class="headerlink" title="维基百科—块运动补偿"></a>维基百科—块运动补偿</h3><p>“运动补偿是一种描述相邻帧（相邻在这里表示在编码关系上相邻，在播放顺序上两帧未必相邻）差别的方法，具体来说是描述前面一帧（相邻在这里表示在编码关系上的前面，在播放顺序上未必在当前帧前面）的每个小块怎样移动到当前帧中的某个位置去。”</p>
</blockquote>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/original_frames_motion_estimation.png" alt="原始帧运动预测" title="原始帧运动预测"></p>
<p>我们预计那个球会从 <code>x=0, y=25</code> 移动到 <code>x=6, y=26</code>，<strong>x</strong> 和 <strong>y</strong> 的值就是<strong>运动向量</strong>。<strong>进一步</strong>节省数据量的方法是，只编码这两者运动向量的差。所以，最终运动向量就是 <code>x=6 (6-0), y=1 (26-25)</code>。</p>
<blockquote>
<p>实际情况下，这个球会被切成 n 个分区，但处理过程是相同的。</p>
</blockquote>
<p>帧上的物体<strong>以三维方式移动</strong>，当球移动到背景时会变小。当我们尝试寻找匹配的块，<strong>找不到完美匹配的块</strong>是正常的。这是一张运动预测与实际值相叠加的图片。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/motion_estimation.png" alt="运动预测" title="运动预测"></p>
<p>但我们能看到当我们使用<strong>运动预测</strong>时，<strong>编码的数据量少于</strong>使用简单的残差帧技术。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/comparison_delta_vs_motion_estimation.png" alt="运动预测 vs 残差 " title="运动预测 vs 残差"></p>
<p>你可以<a href="https://github.com/wangwei1237/wangwei1237.github.io/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/frame_difference_vs_motion_estimation_plus_residual.ipynb" target="_blank" rel="noopener">使用 jupyter 玩转这些概念</a>。</p>
<blockquote>
<h3 id="自己动手：查看运动向量"><a href="#自己动手：查看运动向量" class="headerlink" title="自己动手：查看运动向量"></a>自己动手：查看运动向量</h3><p>我们可以<a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#generate-debug-video" target="_blank" rel="noopener">使用 ffmpeg 生成包含帧间预测（运动向量）的视频</a>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/motion_vectors_ffmpeg.png" alt="ffmpeg 帧间预测（运动向量）" title="ffmpeg 帧间预测（运动向量）"></p>
<p>或者我们也可使用 <a href="https://software.intel.com/en-us/intel-video-pro-analyzer" target="_blank" rel="noopener">Intel® Video Pro Analyzer</a>（需要付费，但也有只能查看前 10 帧的免费试用版）。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/inter_prediction_intel_video_pro_analyzer.png" alt="Intel® Video Pro Analyzer 使用帧间预测" title="inter prediction intel video pro analyzer"></p>
</blockquote>
<h2 id="空间冗余（帧内预测）"><a href="#空间冗余（帧内预测）" class="headerlink" title="空间冗余（帧内预测）"></a>空间冗余（帧内预测）</h2><p>如果我们分析一个视频里的<strong>每一帧</strong>，我们会看到有<strong>许多区域是相互关联的</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/repetitions_in_space.png" alt="空间内重复" title="空间内重复"></p>
<p>让我们举一个例子。这个场景大部分由蓝色和白色组成。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_bg.png" alt="smw 背景" title="smw 背景"></p>
<p>这是一个 <code>I 帧</code>，我们<strong>不能使用前面的帧来预测</strong>，但我们仍然可以压缩它。我们将编码我们选择的那块红色区域。如果我们<strong>看看它的周围</strong>，我们可以<strong>估计它周围颜色的变化</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_bg_block.png" alt="smw 背景块" title="smw 背景块"></p>
<p>我们预测:帧中的颜色在垂直方向上保持一致，这意味着<strong>未知像素的颜色与临近的像素相同</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_bg_prediction.png" alt="smw 背景预测" title="smw 背景预测"></p>
<p>我们的<strong>预测会出错</strong>，所以我们需要先利用这项技术（<strong>帧内预测</strong>），然后<strong>减去实际值</strong>，算出残差，得出的矩阵比原始数据更容易压缩。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/smw_residual.png" alt="smw 残差" title="smw 残差"></p>
<blockquote>
<h3 id="自己动手：查看帧内预测"><a href="#自己动手：查看帧内预测" class="headerlink" title="自己动手：查看帧内预测"></a>自己动手：查看帧内预测</h3><p>你可以<a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#generate-debug-video" target="_blank" rel="noopener">使用 ffmpeg 生成包含宏块及预测的视频</a>。请查看 ffmpeg 文档以了解<a href="https://trac.ffmpeg.org/wiki/Debug/MacroblocksAndMotionVectors" target="_blank" rel="noopener">每个块颜色的含义</a>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/macro_blocks_ffmpeg.png" alt="ffmpeg 帧内预测（宏块）" title="ffmpeg 帧内预测（宏块）"></p>
<p>或者我们也可使用 <a href="https://software.intel.com/en-us/intel-video-pro-analyzer" target="_blank" rel="noopener">Intel® Video Pro Analyzer</a>（需要付费，但也有只能查看前 10 帧的免费试用版）。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/intra_prediction_intel_video_pro_analyzer.png" alt="Intel® Video Pro Analyzer 帧内预测" title="Intel® Video Pro Analyzer 帧内预测"></p>
</blockquote>
<h1 id="视频编解码器是如何工作的？"><a href="#视频编解码器是如何工作的？" class="headerlink" title="视频编解码器是如何工作的？"></a>视频编解码器是如何工作的？</h1><h2 id="是什么？为什么？怎么做？"><a href="#是什么？为什么？怎么做？" class="headerlink" title="是什么？为什么？怎么做？"></a>是什么？为什么？怎么做？</h2><p><strong>是什么？</strong> 就是用于压缩或解压数字视频的软件或硬件。<strong>为什么？</strong> 人们需要在有限带宽或存储空间下提高视频的质量。还记得当我们计算每秒 30 帧，每像素 24 bit，分辨率是 480x240 的视频<a href="#基本术语">需要多少带宽</a>吗？没有压缩时是 <strong>82.944 Mbps</strong>。电视或互联网提供 HD/FullHD/4K 只能靠视频编解码器。<strong>怎么做？</strong> 我们将简单介绍一下主要的技术。</p>
<blockquote>
<p>视频编解码 vs 容器</p>
<p>初学者一个常见的错误是混淆数字视频编解码器和<a href="https://en.wikipedia.org/wiki/Digital_container_format" target="_blank" rel="noopener">数字视频容器</a>。我们可以将<strong>容器</strong>视为包含视频（也很可能包含音频）元数据的包装格式，<strong>压缩过的视频</strong>可以看成是它承载的内容。</p>
<p>通常，视频文件的格式定义其视频容器。例如，文件 <code>video.mp4</code> 可能是 <a href="https://en.wikipedia.org/wiki/MPEG-4_Part_14" target="_blank" rel="noopener">MPEG-4 Part 14</a> 容器，一个叫 <code>video.mkv</code> 的文件可能是 <a href="https://en.wikipedia.org/wiki/Matroska" target="_blank" rel="noopener">matroska</a>。我们可以使用 <a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#inspect-stream" target="_blank" rel="noopener">ffmpeg 或 mediainfo</a> 来完全确定编解码器和容器格式。</p>
</blockquote>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>在我们跳进通用编解码器内部工作之前，让我们回头了解一些旧的视频编解码器。</p>
<p>视频编解码器 <a href="https://en.wikipedia.org/wiki/H.261" target="_blank" rel="noopener">H.261</a> 诞生在 1990（技术上是 1988），被设计为以 <strong>64 kbit/s 的数据速率</strong>工作。它已经使用如色度子采样、宏块，等等理念。在 1995 年，<strong>H.263</strong> 视频编解码器标准被发布，并继续延续到 2001 年。</p>
<p>在 2003 年 <strong>H.264/AVC</strong> 的第一版被完成。在同一年，一家叫做 <strong>TrueMotion</strong> 的公司发布了他们的<strong>免版税</strong>有损视频压缩的视频编解码器，称为 <strong>VP3</strong>。在 2008 年，<strong>Google 收购了</strong>这家公司，在同一年发布 <strong>VP8</strong>。在 2012 年 12 月，Google 发布了 <strong>VP9</strong>，<strong>市面上大约有 3/4 的浏览器</strong>（包括手机）支持。</p>
<p><a href="https://en.wikipedia.org/wiki/AOMedia_Video_1" target="_blank" rel="noopener">AV1</a> 是由 <strong>Google, Mozilla, Microsoft, Amazon, Netflix, AMD, ARM, NVidia, Intel, Cisco</strong> 等公司组成的<a href="http://aomedia.org/" target="_blank" rel="noopener">开放媒体联盟（AOMedia）</a>设计的一种新的视频编解码器，免版税，开源。<strong>第一版</strong> 0.1.0 参考编解码器<strong>发布于 2016 年 4 月 7 号</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/codec_history_timeline.png" alt="编解码器历史线路图" title="编解码器历史线路图"></p>
<blockquote>
<h3 id="AV1-的诞生"><a href="#AV1-的诞生" class="headerlink" title="AV1 的诞生"></a>AV1 的诞生</h3><p>2015 年早期，Google 正在 VP10 上工作，Xiph (Mozilla) 正在 Daala 上工作，Cisco 开源了它的称为 Thor 的免版税视频编解码器。</p>
<p>接着 MPEG LA 宣布了 HEVC (H.265) 每年版税的的上限，比 H.264 高 8 倍，但很快他们又再次改变了条款：</p>
<ul>
<li><strong>不设年度收费上限</strong></li>
<li><strong>收取内容费</strong>（收入的 0.5%）</li>
<li><strong>每单位费用高于 h264 的 10 倍</strong></li>
</ul>
<p><a href="http://aomedia.org/about-us/" target="_blank" rel="noopener">开放媒体联盟</a>由硬件厂商（Intel, AMD, ARM , Nvidia, Cisco），内容分发商（Google, Netflix, Amazon），浏览器维护者（Google, Mozilla），等公司创建。</p>
<p>这些公司有一个共同目标，一个免版税的视频编解码器，所以 AV1 诞生时使用了一个更<a href="http://aomedia.org/license/patent/" target="_blank" rel="noopener">简单的专利许可证</a>。<strong>Timothy B. Terriberry</strong> 做了一个精彩的介绍，<a href="https://www.youtube.com/watch?v=lzPaldsmJbk" target="_blank" rel="noopener">关于 AV1 的概念，许可证模式和它当前的状态</a>，就是本节的来源。</p>
<p>前往 <a href="http://aomanalyzer.org/" target="_blank" rel="noopener">http://aomanalyzer.org/</a>， 你会惊讶于<strong>使用你的浏览器就可以分析 AV1 编解码器</strong>。<br><img src="/2020/02/28/Introduction-to-digital-video-technology/av1_browser_analyzer.png" alt="av1 浏览器分析器" title="浏览器分析器"></p>
<p>附：如果你想了解更多编解码器的历史，你需要了解<a href="https://www.vcodex.com/video-compression-patents/" target="_blank" rel="noopener">视频压缩专利</a>背后的基本知识。</p>
</blockquote>
<h2 id="通用编解码器"><a href="#通用编解码器" class="headerlink" title="通用编解码器"></a>通用编解码器</h2><p>我们接下来要介绍<strong>通用视频编解码器背后的主要机制</strong>，大多数概念都很实用，并被现代编解码器如 VP9, AV1 和 HEVC 使用。需要注意：我们将简化许多内容。有时我们会使用真实的例子（主要是 H.264）来演示技术。</p>
<h2 id="第一步-图片分区"><a href="#第一步-图片分区" class="headerlink" title="第一步 - 图片分区"></a>第一步 - 图片分区</h2><p>第一步是<strong>将帧</strong>分成几个<strong>分区</strong>，<strong>子分区</strong>甚至更多。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/picture_partitioning.png" alt="图片分区" title="图片分区"></p>
<p><strong>但是为什么呢？</strong>有许多原因，比如，当我们分割图片时，我们可以更精确的处理预测，在微小移动的部分使用较小的分区，而在静态背景上使用较大的分区。</p>
<p>通常，编解码器<strong>将这些分区组织</strong>成切片（或瓦片），宏（或编码树单元）和许多子分区。这些分区的最大大小有所不同，HEVC 设置成 64x64，而 AVC 使用 16x16，但子分区可以达到 4x4 的大小。</p>
<p>还记得我们学过的<strong>帧的分类</strong>吗？你也可以<strong>把这些概念应用到块</strong>，因此我们可以有 I 切片，B 切片，I 宏块等等。</p>
<blockquote>
<h3 id="自己动手：查看分区"><a href="#自己动手：查看分区" class="headerlink" title="自己动手：查看分区"></a>自己动手：查看分区</h3><p>我们也可以使用 <a href="https://software.intel.com/en-us/intel-video-pro-analyzer" target="_blank" rel="noopener">Intel® Video Pro Analyzer</a>（需要付费，但也有只能查看前 10 帧的免费试用版）。这是 <a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#transcoding" target="_blank" rel="noopener">VP9 分区</a>的分析。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/paritions_view_intel_video_pro_analyzer.png" alt="Intel® Video Pro Analyzer VP9 分区视图 " title="Intel® Video Pro Analyzer VP9 分区视图"></p>
</blockquote>
<h2 id="第二步-预测"><a href="#第二步-预测" class="headerlink" title="第二步 - 预测"></a>第二步 - 预测</h2><p>一旦我们有了分区，我们就可以在它们之上做出预测。对于<a href="#时间冗余（帧间预测）">帧间预测</a>，我们需要<strong>发送运动向量和残差</strong>；至于<a href="#空间冗余（帧内预测）">帧内预测</a>，我们需要<strong>发送预测方向和残差</strong>。</p>
<h2 id="第三步-转换"><a href="#第三步-转换" class="headerlink" title="第三步 - 转换"></a>第三步 - 转换</h2><p>在我们得到残差块（<code>预测分区-真实分区</code>）之后，我们可以用一种方式<strong>变换</strong>它，这样我们就知道<strong>哪些像素我们应该丢弃</strong>，还依然能保持<strong>整体质量</strong>。这个确切的行为有几种变换方式。</p>
<p>尽管有<a href="https://en.wikipedia.org/wiki/List_of_Fourier-related_transforms#Discrete_transforms" target="_blank" rel="noopener">其它的变换方式</a>，但我们重点关注离散余弦变换（DCT）。<a href="https://en.wikipedia.org/wiki/Discrete_cosine_transform" target="_blank" rel="noopener">DCT</a> 的主要功能有：</p>
<ul>
<li>将<strong>像素</strong>块<strong>转换</strong>为相同大小的<strong>频率系数块</strong>。</li>
<li><strong>压缩</strong>能量，更容易消除空间冗余。</li>
<li><strong>可逆的</strong>，也意味着你可以还原回像素。</li>
</ul>
<blockquote>
<p>2017 年 2 月 2 号，F. M. Bayer 和 R. J. Cintra 发表了他们的论文：<a href="https://arxiv.org/abs/1702.00817" target="_blank" rel="noopener">图像压缩的 DCT 类变换只需要 14 个加法</a>。</p>
</blockquote>
<p>如果你不理解每个要点的好处，不用担心，我们会尝试进行一些实验，以便从中看到真正的价值。</p>
<p>我们来看下面的<strong>像素块</strong>（8x8）：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/pixel_matrice.png" alt="像素值矩形" title="像素值矩形"></p>
<p>下面是其渲染的块图像（8x8）：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/gray_image.png" alt="像素值矩形" title="像素值矩形"></p>
<p>当我们对这个像素块<strong>应用 DCT</strong> 时， 得到如下<strong>系数块</strong>（8x8）：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/dct_coefficient_values.png" alt="系数值 values" title="系数值"></p>
<p>接着如果我们渲染这个系数块，就会得到这张图片：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/dct_coefficient_image.png" alt="dct 系数图片" title="dct 系数图片"></p>
<p>如你所见它看起来完全不像原图像，我们可能会注意到<strong>第一个系数</strong>与其它系数非常不同。第一个系数被称为直流分量，代表了输入数组中的<strong>所有样本</strong>，有点<strong>类似于平均值</strong>。</p>
<p>这个系数块有一个有趣的属性：高频部分和低频部分是分离的。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/dctfrequ.jpg" alt="dct 频率系数属性" title="dct 频率系数属性"></p>
<p>在一张图像中，<strong>大多数能量</strong>会集中在<a href="https://www.iem.thm.de/telekom-labor/zinke/mk/mpeg2beg/whatisit.htm" target="_blank" rel="noopener">低频部分</a>，所以如果我们将图像转换成频率系数，并<strong>丢掉高频系数</strong>，我们就能<strong>减少描述图像所需的数据量</strong>，而不会牺牲太多的图像质量。</p>
<blockquote>
<p>频率是指信号变化的速度。</p>
</blockquote>
<p>让我们通过实验学习这点，我们将使用 DCT 把原始图像转换为频率（系数块），然后丢掉最不重要的系数。</p>
<p>首先，我们将它转换为其<strong>频域</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/dct_coefficient_values.png" alt="系数值" title="系数值"></p>
<p>然后我们丢弃部分（67%）系数，主要是它的右下角部分。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/dct_coefficient_zeroed.png" alt="系数清零" title="系数清零"></p>
<p>然后我们从丢弃的系数块重构图像（记住，这需要可逆），并与原始图像相比较。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/original_vs_quantized.png" alt="原始 vs 量化" title="原始 vs 量化"></p>
<p>如我们所见它酷似原始图像，但它引入了许多与原来的不同，我们<strong>丢弃了67.1875%</strong>，但我们仍然得到至少类似于原来的东西。我们可以更加智能的丢弃系数去得到更好的图像质量，但这是下一个主题。</p>
<blockquote>
<h3 id="使用全部像素形成每个系数"><a href="#使用全部像素形成每个系数" class="headerlink" title="使用全部像素形成每个系数"></a>使用全部像素形成每个系数</h3><p>重要的是要注意，每个系数并不直接映射到单个像素，但它是所有像素的加权和。这个神奇的图形展示了如何计算出第一和第二个系数，使用每个唯一的索引做权重。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/applicat.jpg" alt="dct 计算" title="dct 计算"></p>
<p>来源：<a href="https://web.archive.org/web/20150129171151/https://www.iem.thm.de/telekom-labor/zinke/mk/mpeg2beg/whatisit.htm" target="_blank" rel="noopener">https://web.archive.org/web/20150129171151/https://www.iem.thm.de/telekom-labor/zinke/mk/mpeg2beg/whatisit.htm</a></p>
<p>你也可以尝试<a href="https://github.com/wangwei1237/wangwei1237.github.io/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/dct_better_explained.ipynb" target="_blank" rel="noopener">通过查看在 DCT 基础上形成的简单图片来可视化 DCT</a>。例如，这是使用每个系数权重<a href="https://en.wikipedia.org/wiki/Discrete_cosine_transform#Example_of_IDCT" target="_blank" rel="noopener">形成的字符 A</a>。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/5e/Idct-animation.gif" alt></p>
</blockquote>
<br>

<blockquote>
<h3 id="自己动手：丢弃不同的系数"><a href="#自己动手：丢弃不同的系数" class="headerlink" title="自己动手：丢弃不同的系数"></a>自己动手：丢弃不同的系数</h3><p>你可以玩转 <a href="https://github.com/wangwei1237/wangwei1237.github.io/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/uniform_quantization_experience.ipynb" target="_blank" rel="noopener">DCT 变换</a></p>
</blockquote>
<h2 id="第四步-量化"><a href="#第四步-量化" class="headerlink" title="第四步 - 量化"></a>第四步 - 量化</h2><p>当我们丢弃一些系数时，在最后一步（变换），我们做了一些形式的量化。这一步，我们选择性地剔除信息（<strong>有损部分</strong>）或者简单来说，我们将<strong>量化系数以实现压缩</strong>。</p>
<p>我们如何量化一个系数块？一个简单的方法是均匀量化，我们取一个块并<strong>将其除以单个的值</strong>（10），并舍入值。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/quantize.png" alt="量化" title="量化"></p>
<p>我们如何<strong>逆转</strong>（重新量化）这个系数块？我们可以通过<strong>乘以我们先前除以的相同的值</strong>（10）来做到。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/re-quantize.png" alt="逆转量化" title="逆转量化"></p>
<p>这<strong>不是最好的方法</strong>，因为它没有考虑到每个系数的重要性，我们可以使用一个<strong>量化矩阵</strong>来代替单个值，这个矩阵可以利用 DCT 的属性，多量化右下部，而少（量化）左上部，<a href="https://www.hdm-stuttgart.de/~maucher/Python/MMCodecs/html/jpegUpToQuant.html" target="_blank" rel="noopener">JPEG 使用了类似的方法</a>，你可以通过<a href="https://github.com/google/guetzli/blob/master/guetzli/jpeg_data.h#L40" target="_blank" rel="noopener">查看源码看看这个矩阵</a>。</p>
<blockquote>
<h3 id="自己动手：量化"><a href="#自己动手：量化" class="headerlink" title="自己动手：量化"></a>自己动手：量化</h3><p>你可以玩转<a href="https://github.com/wangwei1237/wangwei1237.github.io/blob/master/2020/02/28/Introduction-to-digital-video-technology/py/dct_experiences.ipynb" target="_blank" rel="noopener">量化</a></p>
</blockquote>
<h2 id="第五步-熵编码"><a href="#第五步-熵编码" class="headerlink" title="第五步 - 熵编码"></a>第五步 - 熵编码</h2><p>在我们量化数据（图像块／切片／帧）之后，我们仍然可以以无损的方式来压缩它。有许多方法（算法）可用来压缩数据。我们将简单体验其中几个，你可以阅读这本很棒的书去深入理解：<a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/" target="_blank" rel="noopener">Understanding Compression: Data Compression for Modern Developers</a>。</p>
<h3 id="VLC-编码："><a href="#VLC-编码：" class="headerlink" title="VLC 编码："></a>VLC 编码：</h3><p>让我们假设我们有一个符号流：<strong>a</strong>, <strong>e</strong>, <strong>r</strong> 和 <strong>t</strong>，它们的概率（从0到1）由下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>e</th>
<th>r</th>
<th>t</th>
</tr>
</thead>
<tbody><tr>
<td>概率</td>
<td>0.3</td>
<td>0.3</td>
<td>0.2</td>
<td>0.2</td>
</tr>
</tbody></table>
<p>我们可以分配不同的二进制码，（最好是）小的码给最可能（出现的字符），大些的码给最少可能（出现的字符）。</p>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>e</th>
<th>r</th>
<th>t</th>
</tr>
</thead>
<tbody><tr>
<td>概率</td>
<td>0.3</td>
<td>0.3</td>
<td>0.2</td>
<td>0.2</td>
</tr>
<tr>
<td>二进制码</td>
<td>0</td>
<td>10</td>
<td>110</td>
<td>1110</td>
</tr>
</tbody></table>
<p>让我们压缩 <strong>eat</strong> 流，假设我们为每个字符花费 8 bit，在没有做任何压缩时我们将花费 <strong>24 bit</strong>。但是在这种情况下，我们使用各自的代码来替换每个字符，我们就能节省空间。</p>
<p>第一步是编码字符 <strong>e</strong> 为 <code>10</code>，第二个字符是 <strong>a</strong>，追加（不是数学加法）后是 <code>[10][0]</code>，最后是第三个字符 <strong>t</strong>，最终组成已压缩的比特流 <code>[10][0][1110]</code> 或 <code>1001110</code>，这只需 <strong>7 bit</strong>（比原来的空间少 3.4 倍）。</p>
<p>请注意每个代码必须是唯一的前缀码，<a href="https://en.wikipedia.org/wiki/Huffman_coding" target="_blank" rel="noopener">Huffman 能帮你找到这些数字</a>。虽然它有一些问题，但是<a href="https://en.wikipedia.org/wiki/Context-adaptive_variable-length_coding" target="_blank" rel="noopener">视频编解码器仍然提供该方法</a>，它也是很多应用程序的压缩算法。</p>
<p>编码器和解码器都<strong>必须知道</strong>这个（包含编码的）字符表，因此，你也需要传送这个表。</p>
<h3 id="算术编码"><a href="#算术编码" class="headerlink" title="算术编码"></a>算术编码</h3><p>让我们假设我们有一个符号流：<strong>a</strong>, <strong>e</strong>, <strong>r</strong>, <strong>s</strong> 和 <strong>t</strong>，它们的概率由下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>e</th>
<th>r</th>
<th>s</th>
<th>t</th>
</tr>
</thead>
<tbody><tr>
<td>概率</td>
<td>0.3</td>
<td>0.3</td>
<td>0.15</td>
<td>0.05</td>
<td>0.2</td>
</tr>
</tbody></table>
<p>考虑到这个表，我们可以构建一个区间，区间包含了所有可能的字符，字符按出现概率排序。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/range.png" alt="初始算法区间" title="初始算法区间"></p>
<p>让我们编码 <strong>eat</strong> 流，我们选择第一个字符 <strong>e</strong> 位于 <strong>0.3 到 0.6</strong> （但不包括 0.6）的子区间，我们选择这个子区间，按照之前同等的比例再次分割。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/second_subrange.png" alt="第二个子区间" title="第二个子区间"></p>
<p>让我们继续编码我们的流 <strong>eat</strong>，现在使第二个 <strong>a</strong> 字符位于 <strong>0.3 到 0.39</strong> 的区间里，接着再次用同样的方法编码最后的字符 <strong>t</strong>，得到最后的子区间 <strong>0.354 到 0.372</strong>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/arithimetic_range.png" alt="最终算法区间" title="最终算法区间"></p>
<p>我们只需从最后的子区间 0.354 到 0.372 里选择一个数，让我们选择 0.36，不过我们可以选择这个子区间里的任何数。仅靠这个数，我们将可以恢复原始流 <strong>eat</strong>。就像我们在区间的区间里画了一根线来编码我们的流。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/range_show.png" alt="最终区间横断面" title="最终区间横断面"></p>
<p><strong>反向过程</strong>（又名解码）一样简单，用数字 <strong>0.36</strong> 和我们原始区间，我们可以进行同样的操作，不过现在是使用这个数字来还原被编码的流。</p>
<p>在第一个区间，我们发现数字落入了一个子区间，因此，这个子区间是我们的第一个字符，现在我们再次切分这个子区间，像之前一样做同样的过程。我们会注意到 <strong>0.36</strong> 落入了 <strong>a</strong> 的区间，然后我们重复这一过程直到得到最后一个字符 <strong>t</strong>（形成我们原始编码过的流 eat）。</p>
<p>编码器和解码器都<strong>必须知道</strong>字符概率表，因此，你也需要传送这个表。</p>
<p>非常巧妙，不是吗？人们能想出这样的解决方案实在是太聪明了，一些<a href="https://en.wikipedia.org/wiki/Context-adaptive_binary_arithmetic_coding" target="_blank" rel="noopener">视频编解码器使用</a>这项技术（或至少提供这一选择）。</p>
<p>关于无损压缩量化比特流的办法，这篇文章无疑缺少了很多细节、原因、权衡等等。作为一个开发者你<a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/" target="_blank" rel="noopener">应该学习更多</a>。刚入门视频编码的人可以尝试使用不同的<a href="https://en.wikipedia.org/wiki/Asymmetric_Numeral_Systems" target="_blank" rel="noopener">熵编码算法，如ANS</a>。</p>
<blockquote>
<h3 id="自己动手：CABAC-vs-CAVLC"><a href="#自己动手：CABAC-vs-CAVLC" class="headerlink" title="自己动手：CABAC vs CAVLC"></a>自己动手：CABAC vs CAVLC</h3><p>你可以<a href="https://github.com/leandromoreira/introduction_video_technology/blob/master/encoding_pratical_examples.md#cabac-vs-cavlc" target="_blank" rel="noopener">生成两个流，一个使用 CABAC，另一个使用 CAVLC</a>，并比较生成每一个的时间以及最终的大小。</p>
</blockquote>
<h2 id="第六步-比特流格式"><a href="#第六步-比特流格式" class="headerlink" title="第六步 - 比特流格式"></a>第六步 - 比特流格式</h2><p>完成所有这些步之后，我们需要将<strong>压缩过的帧和内容打包进去</strong>。需要明确告知解码器<strong>编码定义</strong>，如颜色深度，颜色空间，分辨率，预测信息（运动向量，帧内预测方向），配置<sup>*</sup>，层级<sup>*</sup>，帧率，帧类型，帧号等等更多信息。</p>
<blockquote>
<p><sup>*</sup> 译注：原文为 profile 和 level，没有通用的译名</p>
</blockquote>
<p>我们将简单地学习 H.264 比特流。第一步是<a href="https://github.com/leandromoreira/introduction_video_technology/blob/master/encoding_pratical_examples.md#generate-a-single-frame-h264-bitstream" target="_blank" rel="noopener">生成一个小的 H.264<sup>*</sup> 比特流</a>，可以使用本 repo 和 <a href="http://ffmpeg.org/" target="_blank" rel="noopener">ffmpeg</a> 来做。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;s&#x2F;ffmpeg -i &#x2F;files&#x2F;i&#x2F;minimal.png -pix_fmt yuv420p &#x2F;files&#x2F;v&#x2F;minimal_yuv420.h264</span><br></pre></td></tr></table></figure>

<blockquote>
<p><sup>*</sup> ffmpeg 默认将所有参数添加为 <strong>SEI NAL</strong>，很快我们会定义什么是 NAL。</p>
</blockquote>
<p>这个命令会使用下面的图片作为帧，生成一个具有<strong>单个帧</strong>，64x64 和颜色空间为 yuv420 的原始 h264 比特流。</p>
<blockquote>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/minimal.png" alt="使用帧来生成极简 h264 比特流" title="使用帧来生成极简 h264 比特流"></p>
</blockquote>
<h3 id="H-264-比特流"><a href="#H-264-比特流" class="headerlink" title="H.264 比特流"></a>H.264 比特流</h3><p>AVC (H.264) 标准规定信息将在宏帧（网络概念上的）内传输，称为 <a href="https://en.wikipedia.org/wiki/Network_Abstraction_Layer" target="_blank" rel="noopener">NAL</a>（网络抽象层）。NAL 的主要目标是提供“网络友好”的视频呈现方式，该标准必须适用于电视（基于流），互联网（基于数据包）等。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/nal_units.png" alt="H.264 NAL 单元" title="H.264 NAL 单元"></p>
<p><a href="https://en.wikipedia.org/wiki/Frame_synchronization" target="_blank" rel="noopener">同步标记</a>用来定义 NAL 单元的边界。每个同步标记的值固定为  <code>0x00 0x00 0x01</code> ，最开头的标记例外，它的值是  <code>0x00 0x00 0x00 0x01</code> 。如果我们在生成的 h264 比特流上运行 <strong>hexdump</strong>，我们可以在文件的开头识别至少三个 NAL。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/minimal_yuv420_hex.png" alt="NAL 单元上的同步标记" title="NAL 单元上的同步标记"></p>
<p>我们之前说过，解码器需要知道不仅仅是图片数据，还有视频的详细信息，如：帧、颜色、使用的参数等。每个 NAL 的<strong>第一位</strong>定义了其分类和<strong>类型</strong>。</p>
<table>
<thead>
<tr>
<th>NAL type id</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Undefined</td>
</tr>
<tr>
<td>1</td>
<td>Coded slice of a non-IDR picture</td>
</tr>
<tr>
<td>2</td>
<td>Coded slice data partition A</td>
</tr>
<tr>
<td>3</td>
<td>Coded slice data partition B</td>
</tr>
<tr>
<td>4</td>
<td>Coded slice data partition C</td>
</tr>
<tr>
<td>5</td>
<td><strong>IDR</strong> Coded slice of an IDR picture</td>
</tr>
<tr>
<td>6</td>
<td><strong>SEI</strong> Supplemental enhancement information</td>
</tr>
<tr>
<td>7</td>
<td><strong>SPS</strong> Sequence parameter set</td>
</tr>
<tr>
<td>8</td>
<td><strong>PPS</strong> Picture parameter set</td>
</tr>
<tr>
<td>9</td>
<td>Access unit delimiter</td>
</tr>
<tr>
<td>10</td>
<td>End of sequence</td>
</tr>
<tr>
<td>11</td>
<td>End of stream</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>通常，比特流的第一个 NAL 是 <strong>SPS</strong>，这个类型的 NAL 负责传达通用编码参数，如<strong>配置，层级，分辨率</strong>等。</p>
<p>如果我们跳过第一个同步标记，就可以通过解码<strong>第一个字节</strong>来了解第一个 <strong>NAL 的类型</strong>。</p>
<p>例如同步标记之后的第一个字节是 <code>01100111</code>，第一位（<code>0</code>）是 <strong>forbidden_zero_bit</strong> 字段，接下来的两位（<code>11</code>）告诉我们是 <strong>nal_ref_idc</strong> 字段，其表示该 NAL 是否是参考字段，其余 5 位（<code>00111</code>）告诉我们是 <strong>nal_unit_type</strong> 字段，在这个例子里是 NAL 单元 <strong>SPS</strong> (7)。</p>
<p>SPS NAL 的第 2 位 (<code>binary=01100100, hex=0x64, dec=100</code>) 是 <strong>profile_idc</strong> 字段，显示编码器使用的配置，在这个例子里，我们使用<a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC#Profiles" target="_blank" rel="noopener">受限高配置</a>，一种没有 B（双向预测） 切片支持的高配置。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/minimal_yuv420_bin.png" alt="SPS 二进制视图" title="SPS 二进制视图"></p>
<p>当我们阅读 SPS NAL 的 H.264 比特流规范时，会为<strong>参数名称</strong>，<strong>分类</strong>和<strong>描述</strong>找到许多值，例如，看看字段 <code>pic_width_in_mbs_minus_1</code> 和 <code>pic_height_in_map_units_minus_1</code>。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pic_width_in_mbs_minus_1</td>
<td>0</td>
<td>ue(v)</td>
</tr>
<tr>
<td>pic_height_in_map_units_minus_1</td>
<td>0</td>
<td>ue(v)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>ue(v)</strong>: 无符号整形 <a href="https://pythonhosted.org/bitstring/exp-golomb.html" target="_blank" rel="noopener">Exp-Golomb-coded</a></p>
</blockquote>
<p>如果我们对这些字段的值进行一些计算，将最终得出<strong>分辨率</strong>。我们可以使用值为 <code>119（ (119 + 1) * macroblock_size = 120 * 16 = 1920）</code>的 <code>pic_width_in_mbs_minus_1</code> 表示 <code>1920 x 1080</code>，再次为了减少空间，我们使用 <code>119</code> 来代替编码 <code>1920</code>。</p>
<p>如果我们再次使用二进制视图检查我们创建的视频 (ex: <code>xxd -b -c 11 v/minimal_yuv420.h264</code>)，可以跳到帧自身上一个 NAL。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/slice_nal_idr_bin.png" alt="h264 idr 切片头" title="h264 idr 切片头"></p>
<p>我们可以看到最开始的 6 个字节：<code>01100101 10001000 10000100 00000000 00100001 11111111</code>。我们已经知道第一个字节告诉我们 NAL 的类型，在这个例子里， (<code>00101</code>) 是 <strong>IDR 切片 (5)</strong>，可以进一步检查它：</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/slice_header.png" alt="h264 切片头规格" title="h264 切片头规格"></p>
<p>对照规范，我们能解码切片的类型（<strong>slice_type</strong>），帧号（<strong>frame_num</strong>）等重要字段。</p>
<p>为了获得一些字段（<code>ue(v), me(v), se(v) 或 te(v)</code>）的值，我们需要称为 <a href="https://pythonhosted.org/bitstring/exp-golomb.html" target="_blank" rel="noopener">Exponential-Golomb</a> 的特定解码器来解码它。当存在很多默认值时，这个方法编码变量值特别高效。</p>
<blockquote>
<p>这个视频里 <strong>slice_type</strong> 和 <strong>frame_num</strong> 的值是 7（I 切片）和 0（第一帧）。</p>
</blockquote>
<p>我们可以将<strong>比特流视为一个协议</strong>，如果你想学习更多关于比特流的内容，请参考 <a href="http://www.itu.int/rec/T-REC-H.264-201610-I" target="_blank" rel="noopener">ITU H.264 规范</a>。这个宏观图展示了图片数据（压缩过的 YUV）所在的位置。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/h264_bitstream_macro_diagram.png" alt="h264 比特流宏观图" title="h264 比特流宏观图"></p>
<p>我们可以探究其它比特流，如 <a href="https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.6-20160331-draft.pdf" target="_blank" rel="noopener">VP9 比特流</a>，<a href="http://handle.itu.int/11.1002/1000/11885-en?locatt=format:pdf" target="_blank" rel="noopener">H.265（HEVC）</a>或是我们的新朋友 <a href="https://medium.com/@mbebenita/av1-bitstream-analyzer-d25f1c27072b#.d5a89oxz8" target="_blank" rel="noopener">AV1 比特流</a>，<a href="http://www.gpac-licensing.com/2016/07/12/vp9-av1-bitstream-format/" target="_blank" rel="noopener">他们很相似吗？不</a>，但只要学习了其中之一，学习其他的就简单多了。</p>
<blockquote>
<h3 id="自己动手：检查-H-264-比特流"><a href="#自己动手：检查-H-264-比特流" class="headerlink" title="自己动手：检查 H.264 比特流"></a>自己动手：检查 H.264 比特流</h3><p>我们可以<a href="https://github.com/leandromoreira/introduction_video_technology/blob/master/encoding_pratical_examples.md#generate-a-single-frame-video" target="_blank" rel="noopener">生成一个单帧视频</a>，使用 <a href="https://en.wikipedia.org/wiki/MediaInfo" target="_blank" rel="noopener">mediainfo</a> 检查它的 H.264 比特流。事实上，你甚至可以查看<a href="https://github.com/MediaArea/MediaInfoLib/blob/master/Source/MediaInfo/Video/File_Avc.cpp" target="_blank" rel="noopener">解析 h264(AVC) 视频流的源代码</a>。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/mediainfo_details_1.png" alt="mediainfo h264 比特流的详情 " title="mediainfo h264 比特流的详情"></p>
<p>我们也可使用 <a href="https://software.intel.com/en-us/intel-video-pro-analyzer" target="_blank" rel="noopener">Intel® Video Pro Analyzer</a>，需要付费，但也有只能查看前 10 帧的免费试用版，这已经够达成学习目的了。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/intel-video-pro-analyzer.png" alt="Intel® Video Pro Analyzer h264 比特流的详情" title="Intel® Video Pro Analyzer h264 比特流的详情"></p>
</blockquote>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>我们可以看到我们学了许多<strong>使用相同模型的现代编解码器</strong>。事实上，让我们看看 Thor 视频编解码器框图，它包含所有我们学过的步骤。你现在应该能更好地理解数字视频领域内的创新和论文。<br><img src="/2020/02/28/Introduction-to-digital-video-technology/thor_codec_block_diagram.png" alt="thor 编解码器块图" title="thor 编解码器块图"></p>
<p>之前我们计算过我们<a href="#色度子采样">需要 139GB 来保存一个一小时，720p 分辨率和30fps的视频文件</a>，如果我们使用在这里学过的技术，如<strong>帧间和帧内预测，转换，量化，熵编码和其它</strong>我们能实现——假设我们<strong>每像素花费 0.031 bit</strong>——同样观感质量的视频，<strong>对比 139GB 的存储，只需 367.82MB</strong>。</p>
<blockquote>
<p>我们根据这里提供的示例视频选择<strong>每像素使用 0.031 bit</strong>。</p>
</blockquote>
<h2 id="H-265-如何实现比-H-264-更好的压缩率"><a href="#H-265-如何实现比-H-264-更好的压缩率" class="headerlink" title="H.265 如何实现比 H.264 更好的压缩率"></a>H.265 如何实现比 H.264 更好的压缩率</h2><p>我们已经更多地了解了编解码器的工作原理，那么就容易理解新的编解码器如何使用更少的数据量传输更高分辨率的视频。</p>
<p>我们将比较 AVC 和 HEVC，要记住的是：我们几乎总是要在压缩率和更多的 CPU 周期（复杂度）之间作权衡。</p>
<p>HEVC 比 AVC 有更大和更多的<strong>分区</strong>（和<strong>子分区</strong>）选项，更多<strong>帧内预测方向</strong>，<strong>改进的熵编码</strong>等，所有这些改进使得 H.265 比 H.264 的压缩率提升 50%。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/avc_vs_hevc.png" alt="h264 vs h265" title="H.264 vs H.265"></p>
<h1 id="在线流媒体"><a href="#在线流媒体" class="headerlink" title="在线流媒体"></a>在线流媒体</h1><h2 id="通用架构"><a href="#通用架构" class="headerlink" title="通用架构"></a>通用架构</h2><p><img src="/2020/02/28/Introduction-to-digital-video-technology/general_architecture.png" alt="general_architecture"></p>
<p>[TODO]</p>
<h2 id="渐进式下载和自适应流"><a href="#渐进式下载和自适应流" class="headerlink" title="渐进式下载和自适应流"></a>渐进式下载和自适应流</h2><p><img src="/2020/02/28/Introduction-to-digital-video-technology/progressive_download.png" alt="progressive_download"></p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/adaptive_streaming.png" alt="adaptive_streaming"></p>
<p>[TODO]</p>
<h2 id="内容保护"><a href="#内容保护" class="headerlink" title="内容保护"></a>内容保护</h2><p>我们可以用一个简单的令牌认证系统来保护视频。用户需要拥有一个有效的令牌才可以播放视频，CDN 会拒绝没有令牌的用户的请求。它与大多数网站的身份认证系统非常相似。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/token_protection.png" alt="token_protection"></p>
<p>仅仅使用令牌认证系统，用户仍然可以下载并重新分发视频。DRM 系统可以用来避免这种情况。</p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/drm.png" alt="drm"></p>
<p>实际情况下，人们通常同时使用这两种技术提供授权和认证。</p>
<h3 id="DRM"><a href="#DRM" class="headerlink" title="DRM"></a>DRM</h3><h4 id="主要系统"><a href="#主要系统" class="headerlink" title="主要系统"></a>主要系统</h4><ul>
<li>FPS - <a href="https://developer.apple.com/streaming/fps/" target="_blank" rel="noopener"><strong>FairPlay Streaming</strong></a></li>
<li>PR - <a href="https://www.microsoft.com/playready/" target="_blank" rel="noopener"><strong>PlayReady</strong></a></li>
<li>WV - <a href="http://www.widevine.com/" target="_blank" rel="noopener"><strong>Widevine</strong></a></li>
</ul>
<h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>DRM 指的是数字版权管理，是一种<strong>为数字媒体提供版权保护</strong>的方法，例如数字视频和音频。尽管用在了很多场合，但它并<a href="https://en.wikipedia.org/wiki/Digital_rights_management#DRM-free_works" target="_blank" rel="noopener">没有被普遍接受</a>.</p>
<h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>内容的创作者（大多是工作室/制片厂）希望保护他们的知识产权，使他们的数字媒体免遭未经授权的分发。</p>
<h4 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h4><p>我们将用一种简单的、抽象的方式描述 DRM</p>
<p>现有一份<strong>内容 C1</strong>（如 HLS 或 DASH 视频流），一个<strong>播放器 P1</strong>（如 shaka-clappr, exo-player 或 iOS），装在<strong>设备 D1</strong>（如智能手机、电视或台式机/笔记本）上，使用 <strong>DRM 系统 DRM1</strong>（如 FairPlay Streaming, PlayReady, Widevine）</p>
<p>内容 C1 由 DRM1 用一个<strong>对称密钥 K1</strong> 加密，生成<strong>加密内容 C’1</strong></p>
<p><img src="/2020/02/28/Introduction-to-digital-video-technology/drm_general_flow.jpeg" alt="DRM 一般流程" title="DRM 一般流程"></p>
<p>设备 D1 上的播放器 P1 有一个非对称密钥对，密钥对包含一个<strong>私钥 PRK1</strong>（这个密钥是受保护的<sup>1</sup>，只有 <strong>D1</strong> 知道密钥内容），和一个<strong>公钥 PUK1</strong></p>
<blockquote>
<p><strong><sup>1</sup>受保护的</strong>: 这种保护可以<strong>通过硬件</strong>进行保护，例如, 将这个密钥存储在一个特殊的芯片（只读）中，芯片的工作方式就像一个用来解密的[黑箱]。 或<strong>通过软件</strong>进行保护（较低的安全系数）。DRM 系统提供了识别设备所使用的保护类型的方法。</p>
</blockquote>
<p>当 <strong>播放器 P1 希望播放**</strong>加密内容 C’1** 时，它需要与 <strong>DRM1</strong> 协商，将公钥 <strong>PUK1</strong> 发送给 DRM1, DRM1 会返回一个被公钥 <strong>PUK1</strong> <strong>加密过的 K1</strong>。按照推论，结果就是<strong>只有 D1 能够解密</strong>。</p>
<p><code>K1P1D1 = enc(K1, PUK1)</code></p>
<p><strong>P1</strong> 使用它的本地 DRM 系统（这可以使用 <a href="https://zh.wikipedia.org/wiki/系统芯片" target="_blank" rel="noopener">SoC</a> ，一个专门的硬件和软件，这个系统可以使用它的私钥 PRK1 用来<strong>解密</strong>内容，它可以解密被加密过的<strong>K1P1D1 的对称密钥 K1</strong>。理想情况下，密钥不会被导出到内存以外的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">K1 &#x3D; dec(K1P1D1, PRK1)</span><br><span class="line"></span><br><span class="line">P1.play(dec(C&#39;1, K1))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/28/Introduction-to-digital-video-technology/drm_decoder_flow.jpeg" alt="DRM 解码流程" title="DRM 解码流程"></p>
<h1 id="如何使用-jupyter"><a href="#如何使用-jupyter" class="headerlink" title="如何使用 jupyter"></a>如何使用 jupyter</h1><p>确保你已安装 docker，只需运行 <code>./s/start_jupyter.sh</code>，然后按照控制台的说明进行操作。</p>
<h1 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h1><ul>
<li><a href="https://demuxed.com/" target="_blank" rel="noopener">DEMUXED</a> - 您可以<a href="https://www.youtube.com/channel/UCIc_DkRxo9UgUSTvWVNCmpA" target="_blank" rel="noopener">查看最近的2个活动演示</a>。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>这里有最丰富的资源，这篇文档包含的信息，均摘录、依据或受它们启发。你可以用这些精彩的链接，书籍，视频等深化你的知识。</p>
<p>在线课程和教程：</p>
<ul>
<li><a href="https://www.coursera.org/learn/digital/" target="_blank" rel="noopener">https://www.coursera.org/learn/digital/</a></li>
<li><a href="https://people.xiph.org/~tterribe/pubs/lca2012/auckland/intro_to_video1.pdf" target="_blank" rel="noopener">https://people.xiph.org/~tterribe/pubs/lca2012/auckland/intro_to_video1.pdf</a></li>
<li><a href="https://xiph.org/video/vid1.shtml" target="_blank" rel="noopener">https://xiph.org/video/vid1.shtml</a></li>
<li><a href="https://xiph.org/video/vid2.shtml" target="_blank" rel="noopener">https://xiph.org/video/vid2.shtml</a></li>
<li><a href="http://slhck.info/ffmpeg-encoding-course" target="_blank" rel="noopener">http://slhck.info/ffmpeg-encoding-course</a></li>
<li><a href="http://www.cambridgeincolour.com/tutorials/camera-sensors.htm" target="_blank" rel="noopener">http://www.cambridgeincolour.com/tutorials/camera-sensors.htm</a></li>
<li><a href="http://www.slideshare.net/vcodex/a-short-history-of-video-coding" target="_blank" rel="noopener">http://www.slideshare.net/vcodex/a-short-history-of-video-coding</a></li>
<li><a href="http://www.slideshare.net/vcodex/introduction-to-video-compression-13394338" target="_blank" rel="noopener">http://www.slideshare.net/vcodex/introduction-to-video-compression-1339433</a></li>
<li><a href="https://developer.android.com/guide/topics/media/media-formats.html" target="_blank" rel="noopener">https://developer.android.com/guide/topics/media/media-formats.html</a></li>
<li><a href="http://www.slideshare.net/MadhawaKasun/audio-compression-23398426" target="_blank" rel="noopener">http://www.slideshare.net/MadhawaKasun/audio-compression-23398426</a></li>
<li><a href="http://inst.eecs.berkeley.edu/~ee290t/sp04/lectures/02-Motion_Compensation_girod.pdf" target="_blank" rel="noopener">http://inst.eecs.berkeley.edu/~ee290t/sp04/lectures/02-Motion_Compensation_girod.pdf</a></li>
</ul>
<p>书籍:</p>
<ul>
<li><a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/ref=sr_1_1?s=books&ie=UTF8&qid=1486395327&sr=1-1" target="_blank" rel="noopener">https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1486395327&amp;sr=1-1</a></li>
<li><a href="https://www.amazon.com/H-264-Advanced-Video-Compression-Standard/dp/0470516925" target="_blank" rel="noopener">https://www.amazon.com/H-264-Advanced-Video-Compression-Standard/dp/0470516925</a></li>
<li><a href="https://www.amazon.com/Practical-Guide-Video-Audio-Compression/dp/0240806301/ref=sr_1_3?s=books&ie=UTF8&qid=1486396914&sr=1-3&keywords=A+PRACTICAL+GUIDE+TO+VIDEO+AUDIO" target="_blank" rel="noopener">https://www.amazon.com/Practical-Guide-Video-Audio-Compression/dp/0240806301/ref=sr_1_3?s=books&amp;ie=UTF8&amp;qid=1486396914&amp;sr=1-3&amp;keywords=A+PRACTICAL+GUIDE+TO+VIDEO+AUDIO</a></li>
<li><a href="https://www.amazon.com/Video-Encoding-Numbers-Eliminate-Guesswork/dp/0998453005/ref=sr_1_1?s=books&ie=UTF8&qid=1486396940&sr=1-1&keywords=jan+ozer" target="_blank" rel="noopener">https://www.amazon.com/Video-Encoding-Numbers-Eliminate-Guesswork/dp/0998453005/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1486396940&amp;sr=1-1&amp;keywords=jan+ozer</a></li>
</ul>
<p>比特流规范:</p>
<ul>
<li><a href="http://www.itu.int/rec/T-REC-H.264-201610-I" target="_blank" rel="noopener">http://www.itu.int/rec/T-REC-H.264-201610-I</a></li>
<li><a href="http://www.itu.int/ITU-T/recommendations/rec.aspx?rec=12904&lang=en" target="_blank" rel="noopener">http://www.itu.int/ITU-T/recommendations/rec.aspx?rec=12904&amp;lang=en</a></li>
<li><a href="https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.6-20160331-draft.pdf" target="_blank" rel="noopener">https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.6-20160331-draft.pdf</a></li>
<li><a href="http://iphome.hhi.de/wiegand/assets/pdfs/2012_12_IEEE-HEVC-Overview.pdf" target="_blank" rel="noopener">http://iphome.hhi.de/wiegand/assets/pdfs/2012_12_IEEE-HEVC-Overview.pdf</a></li>
<li><a href="http://phenix.int-evry.fr/jct/doc_end_user/current_document.php?id=7243" target="_blank" rel="noopener">http://phenix.int-evry.fr/jct/doc_end_user/current_document.php?id=7243</a></li>
<li><a href="http://gentlelogic.blogspot.com.br/2011/11/exploring-h264-part-2-h264-bitstream.html" target="_blank" rel="noopener">http://gentlelogic.blogspot.com.br/2011/11/exploring-h264-part-2-h264-bitstream.html</a></li>
</ul>
<p>软件:</p>
<ul>
<li><a href="https://ffmpeg.org/" target="_blank" rel="noopener">https://ffmpeg.org/</a></li>
<li><a href="https://ffmpeg.org/ffmpeg-all.html" target="_blank" rel="noopener">https://ffmpeg.org/ffmpeg-all.html</a></li>
<li><a href="https://ffmpeg.org/ffprobe.html" target="_blank" rel="noopener">https://ffmpeg.org/ffprobe.html</a></li>
<li><a href="https://trac.ffmpeg.org/wiki/" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/</a></li>
<li><a href="https://software.intel.com/en-us/intel-video-pro-analyzer" target="_blank" rel="noopener">https://software.intel.com/en-us/intel-video-pro-analyzer</a></li>
<li><a href="https://medium.com/@mbebenita/av1-bitstream-analyzer-d25f1c27072b#.d5a89oxz8" target="_blank" rel="noopener">https://medium.com/@mbebenita/av1-bitstream-analyzer-d25f1c27072b#.d5a89oxz8</a></li>
</ul>
<p>非-ITU 编解码器:</p>
<ul>
<li><a href="https://aomedia.googlesource.com/" target="_blank" rel="noopener">https://aomedia.googlesource.com/</a></li>
<li><a href="https://github.com/webmproject/libvpx/tree/master/vp9" target="_blank" rel="noopener">https://github.com/webmproject/libvpx/tree/master/vp9</a></li>
<li><a href="https://people.xiph.org/~xiphmont/demo/daala/demo1.shtml" target="_blank" rel="noopener">https://people.xiph.org/~xiphmont/demo/daala/demo1.shtml</a></li>
<li><a href="https://people.xiph.org/~jm/daala/revisiting/" target="_blank" rel="noopener">https://people.xiph.org/~jm/daala/revisiting/</a></li>
<li><a href="https://www.youtube.com/watch?v=lzPaldsmJbk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=lzPaldsmJbk</a></li>
<li><a href="https://fosdem.org/2017/schedule/event/om_av1/" target="_blank" rel="noopener">https://fosdem.org/2017/schedule/event/om_av1/</a></li>
</ul>
<p>编码概念:</p>
<ul>
<li><a href="http://x265.org/hevc-h265/" target="_blank" rel="noopener">http://x265.org/hevc-h265/</a></li>
<li><a href="http://slhck.info/video/2017/03/01/rate-control.html" target="_blank" rel="noopener">http://slhck.info/video/2017/03/01/rate-control.html</a></li>
<li><a href="http://slhck.info/video/2017/02/24/vbr-settings.html" target="_blank" rel="noopener">http://slhck.info/video/2017/02/24/vbr-settings.html</a></li>
<li><a href="http://slhck.info/video/2017/02/24/crf-guide.html" target="_blank" rel="noopener">http://slhck.info/video/2017/02/24/crf-guide.html</a></li>
<li><a href="https://arxiv.org/pdf/1702.00817v1.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1702.00817v1.pdf</a></li>
<li><a href="https://trac.ffmpeg.org/wiki/Debug/MacroblocksAndMotionVectors" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/Debug/MacroblocksAndMotionVectors</a></li>
<li><a href="http://web.ece.ucdavis.edu/cerl/ReliableJPEG/Cung/jpeg.html" target="_blank" rel="noopener">http://web.ece.ucdavis.edu/cerl/ReliableJPEG/Cung/jpeg.html</a></li>
<li><a href="http://www.adobe.com/devnet/adobe-media-server/articles/h264_encoding.html" target="_blank" rel="noopener">http://www.adobe.com/devnet/adobe-media-server/articles/h264_encoding.html</a></li>
<li><a href="https://prezi.com/8m7thtvl4ywr/mp3-and-aac-explained/" target="_blank" rel="noopener">https://prezi.com/8m7thtvl4ywr/mp3-and-aac-explained/</a></li>
</ul>
<p>测试用视频序列:</p>
<ul>
<li><a href="http://bbb3d.renderfarming.net/download.html" target="_blank" rel="noopener">http://bbb3d.renderfarming.net/download.html</a></li>
<li><a href="https://www.its.bldrdoc.gov/vqeg/video-datasets-and-organizations.aspx" target="_blank" rel="noopener">https://www.its.bldrdoc.gov/vqeg/video-datasets-and-organizations.aspx</a></li>
</ul>
<p>杂项:</p>
<ul>
<li><a href="http://stackoverflow.com/a/24890903" target="_blank" rel="noopener">http://stackoverflow.com/a/24890903</a></li>
<li><a href="http://stackoverflow.com/questions/38094302/how-to-understand-header-of-h264" target="_blank" rel="noopener">http://stackoverflow.com/questions/38094302/how-to-understand-header-of-h264</a></li>
<li><a href="http://techblog.netflix.com/2016/08/a-large-scale-comparison-of-x264-x265.html" target="_blank" rel="noopener">http://techblog.netflix.com/2016/08/a-large-scale-comparison-of-x264-x265.html</a></li>
<li><a href="http://vanseodesign.com/web-design/color-luminance/" target="_blank" rel="noopener">http://vanseodesign.com/web-design/color-luminance/</a></li>
<li><a href="http://www.biologymad.com/nervoussystem/eyenotes.htm" target="_blank" rel="noopener">http://www.biologymad.com/nervoussystem/eyenotes.htm</a></li>
<li><a href="http://www.compression.ru/video/codec_comparison/h264_2012/mpeg4_avc_h264_video_codecs_comparison.pdf" target="_blank" rel="noopener">http://www.compression.ru/video/codec_comparison/h264_2012/mpeg4_avc_h264_video_codecs_comparison.pdf</a></li>
<li><a href="http://www.csc.villanova.edu/~rschumey/csc4800/dct.html" target="_blank" rel="noopener">http://www.csc.villanova.edu/~rschumey/csc4800/dct.html</a></li>
<li><a href="http://www.explainthatstuff.com/digitalcameras.html" target="_blank" rel="noopener">http://www.explainthatstuff.com/digitalcameras.html</a></li>
<li><a href="http://www.hkvstar.com" target="_blank" rel="noopener">http://www.hkvstar.com</a></li>
<li><a href="http://www.hometheatersound.com/" target="_blank" rel="noopener">http://www.hometheatersound.com/</a></li>
<li><a href="http://www.lighterra.com/papers/videoencodingh264/" target="_blank" rel="noopener">http://www.lighterra.com/papers/videoencodingh264/</a></li>
<li><a href="http://www.red.com/learn/red-101/video-chroma-subsampling" target="_blank" rel="noopener">http://www.red.com/learn/red-101/video-chroma-subsampling</a></li>
<li><a href="http://www.slideshare.net/ManoharKuse/hevc-intra-coding" target="_blank" rel="noopener">http://www.slideshare.net/ManoharKuse/hevc-intra-coding</a></li>
<li><a href="http://www.slideshare.net/mwalendo/h264vs-hevc" target="_blank" rel="noopener">http://www.slideshare.net/mwalendo/h264vs-hevc</a></li>
<li><a href="http://www.slideshare.net/rvarun7777/final-seminar-46117193" target="_blank" rel="noopener">http://www.slideshare.net/rvarun7777/final-seminar-46117193</a></li>
<li><a href="http://www.springer.com/cda/content/document/cda_downloaddocument/9783642147029-c1.pdf" target="_blank" rel="noopener">http://www.springer.com/cda/content/document/cda_downloaddocument/9783642147029-c1.pdf</a></li>
<li><a href="http://www.streamingmedia.com/Articles/Editorial/Featured-Articles/A-Progress-Report-The-Alliance-for-Open-Media-and-the-AV1-Codec-110383.aspx" target="_blank" rel="noopener">http://www.streamingmedia.com/Articles/Editorial/Featured-Articles/A-Progress-Report-The-Alliance-for-Open-Media-and-the-AV1-Codec-110383.aspx</a></li>
<li><a href="http://www.streamingmediaglobal.com/Articles/ReadArticle.aspx?ArticleID=116505&PageNum=1" target="_blank" rel="noopener">http://www.streamingmediaglobal.com/Articles/ReadArticle.aspx?ArticleID=116505&amp;PageNum=1</a></li>
<li><a href="http://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit/" target="_blank" rel="noopener">http://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit/</a></li>
<li><a href="https://cardinalpeak.com/blog/the-h-264-sequence-parameter-set/" target="_blank" rel="noopener">https://cardinalpeak.com/blog/the-h-264-sequence-parameter-set/</a></li>
<li><a href="https://cardinalpeak.com/blog/worlds-smallest-h-264-encoder/" target="_blank" rel="noopener">https://cardinalpeak.com/blog/worlds-smallest-h-264-encoder/</a></li>
<li><a href="https://codesequoia.wordpress.com/category/video/" target="_blank" rel="noopener">https://codesequoia.wordpress.com/category/video/</a></li>
<li><a href="https://developer.apple.com/library/content/technotes/tn2224/_index.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/technotes/tn2224/_index.html</a></li>
<li><a href="https://en.wikibooks.org/wiki/MeGUI/x264_Settings" target="_blank" rel="noopener">https://en.wikibooks.org/wiki/MeGUI/x264_Settings</a></li>
<li><a href="https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming</a></li>
<li><a href="https://en.wikipedia.org/wiki/AOMedia_Video_1" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/AOMedia_Video_1</a></li>
<li><a href="https://en.wikipedia.org/wiki/Chroma_subsampling#/media/File:Colorcomp.jpg" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Chroma_subsampling#/media/File:Colorcomp.jpg</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cone_cell" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cone_cell</a></li>
<li><a href="https://en.wikipedia.org/wiki/File:H.264_block_diagram_with_quality_score.jpg" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/File:H.264_block_diagram_with_quality_score.jpg</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inter_frame" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Inter_frame</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intra-frame_coding" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Intra-frame_coding</a></li>
<li><a href="https://en.wikipedia.org/wiki/Photoreceptor_cell" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Photoreceptor_cell</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pixel_aspect_ratio" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pixel_aspect_ratio</a></li>
<li><a href="https://en.wikipedia.org/wiki/Presentation_timestamp" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Presentation_timestamp</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rod_cell" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rod_cell</a></li>
<li><a href="https://it.wikipedia.org/wiki/File:Pixel_geometry_01_Pengo.jpg" target="_blank" rel="noopener">https://it.wikipedia.org/wiki/File:Pixel_geometry_01_Pengo.jpg</a></li>
<li><a href="https://leandromoreira.com.br/2016/10/09/how-to-measure-video-quality-perception/" target="_blank" rel="noopener">https://leandromoreira.com.br/2016/10/09/how-to-measure-video-quality-perception/</a></li>
<li><a href="https://sites.google.com/site/linuxencoding/x264-ffmpeg-mapping" target="_blank" rel="noopener">https://sites.google.com/site/linuxencoding/x264-ffmpeg-mapping</a></li>
<li><a href="https://softwaredevelopmentperestroika.wordpress.com/2014/02/11/image-processing-with-python-numpy-scipy-image-convolution/" target="_blank" rel="noopener">https://softwaredevelopmentperestroika.wordpress.com/2014/02/11/image-processing-with-python-numpy-scipy-image-convolution/</a></li>
<li><a href="https://tools.ietf.org/html/draft-fuldseth-netvc-thor-03" target="_blank" rel="noopener">https://tools.ietf.org/html/draft-fuldseth-netvc-thor-03</a></li>
<li><a href="https://www.encoding.com/android/" target="_blank" rel="noopener">https://www.encoding.com/android/</a></li>
<li><a href="https://www.encoding.com/http-live-streaming-hls/" target="_blank" rel="noopener">https://www.encoding.com/http-live-streaming-hls/</a></li>
<li><a href="https://www.iem.thm.de/telekom-labor/zinke/mk/mpeg2beg/whatisit.htm" target="_blank" rel="noopener">https://www.iem.thm.de/telekom-labor/zinke/mk/mpeg2beg/whatisit.htm</a></li>
<li><a href="https://www.lifewire.com/cmos-image-sensor-493271" target="_blank" rel="noopener">https://www.lifewire.com/cmos-image-sensor-493271</a></li>
<li><a href="https://www.linkedin.com/pulse/brief-history-video-codecs-yoav-nativ" target="_blank" rel="noopener">https://www.linkedin.com/pulse/brief-history-video-codecs-yoav-nativ</a></li>
<li><a href="https://www.linkedin.com/pulse/video-streaming-methodology-reema-majumdar" target="_blank" rel="noopener">https://www.linkedin.com/pulse/video-streaming-methodology-reema-majumdar</a></li>
<li><a href="https://www.vcodex.com/h264avc-intra-precition/" target="_blank" rel="noopener">https://www.vcodex.com/h264avc-intra-precition/</a></li>
<li><a href="https://www.youtube.com/watch?v=9vgtJJ2wwMA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=9vgtJJ2wwMA</a></li>
<li><a href="https://www.youtube.com/watch?v=LFXN9PiOGtY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=LFXN9PiOGtY</a></li>
<li><a href="https://www.youtube.com/watch?v=Lto-ajuqW3w&list=PLzH6n4zXuckpKAj1_88VS-8Z6yn9zX_P6" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Lto-ajuqW3w&amp;list=PLzH6n4zXuckpKAj1_88VS-8Z6yn9zX_P6</a></li>
<li><a href="https://www.youtube.com/watch?v=LWxu4rkZBLw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=LWxu4rkZBLw</a></li>
</ul>
]]></content>
      <categories>
        <category>视频技术</category>
      </categories>
      <tags>
        <tag>数字视频</tag>
      </tags>
  </entry>
  <entry>
    <title>如何计算MS-SSIM</title>
    <url>/2020/02/25/how-to-calculate-the-MS-SSIM/</url>
    <content><![CDATA[<h2 id="SSIM的本质及其缺点"><a href="#SSIM的本质及其缺点" class="headerlink" title="SSIM的本质及其缺点"></a>SSIM的本质及其缺点</h2><p>在<a href="/2020/02/15/how-to-calculate-the-SSIM-in-FFMpeg/">FFMpeg如何计算图像的SSIM</a>中，详细介绍了$SSIM$的相关概念，并对FFMpeg中的$SSIM$实现做了详细的分析。$SSIM$算法基于HVS更擅长从图像中提取结构信息的事实，并且利用结构相似度来计算图像的感知质量。在Z. Wang等人的论文<strong>Multi-scale structural similarity for image quality assessment</strong>中也提到，$SSIM$算法要好于当时的其它的感知图像质量指标。</p>
<p>就其本质而言，$SSIM$是一种单尺度的算法，但是实际上正确的图像尺度取决于用户的观看条件，例如显示设备的分辨率，用户的观看距离等。因此，用单尺度的$SSIM$算法来评估图像的感知质量也存在其缺点。</p>
<a id="more"></a>

<h2 id="MS-SSIM的基本概念"><a href="#MS-SSIM的基本概念" class="headerlink" title="MS-SSIM的基本概念"></a>MS-SSIM的基本概念</h2><p>图像细节的可感知性取决于：</p>
<ul>
<li>图像信号的采样密度</li>
<li>用户的观看距离</li>
<li>HVS的感知能力</li>
</ul>
<p>当如上的因素发生变化时，则对给定图像的主观评估也会随之发生变化。单尺度的SSIM算法可能仅适用于某个特定的配置。为了解决该问题，论文<strong>Multi-scale structural similarity for image quality assessment</strong>在$SSIM$算法的基础上提出了如图1所示的多尺度的结构相似性评估算法，即$MS-SSIM$算法。</p>
<p><img src="/2020/02/25/how-to-calculate-the-MS-SSIM/1.jpg" alt="图1. MS-SSIM算法"></p>
<p>图1. MS-SSIM算法，L 表示低通滤波器，2↓ 表示采样间隔为2的下采样</p>
<p>因此，$MS-SSIM$实际上是一种以不同分辨率合并图像细节的图像质量评估方法。对于$MS-SSIM$，原始图像的$scale=1$，图像的最大$scale=M$。对$scale=j$的尺度而言，其亮度、对比度、结构的相似性分别表示为：</p>
<ul>
<li>$l_j(X,Y)$</li>
<li>$c_j(X,Y)$</li>
<li>$s_j(X,Y)$</li>
</ul>
<p>因此，根据图1可以得到$MS-SSIM$的计算方式。</p>
<p>$$<br>MS-SSIM(X,Y)=\big[l_M(X,Y)\big]^{\alpha_M} \cdot \prod _{j=1}^{M}  {\big[c_j(X,Y)\big]^{\beta_j}\big[s_j(X,Y)\big]^{\gamma_j}}<br>$$</p>
<p>一般，令$\alpha_j=\beta_j=\gamma_j \ \ , \ j \in [1, M]$，我们得到：</p>
<p>$$<br>MS-SSIM(X,Y)=\big[l_M(X,Y)\big]^{\alpha_M} \cdot \prod _{j=1}^{M}  {\big[c_j(X,Y) \cdot s_j(X,Y)\big]^{\alpha_j}}<br>$$</p>
<p><strong>Multi-scale structural similarity for image quality assessment</strong>给出了一种计算各尺度参数的方法，并同时给出不同尺度的参数值：</p>
<ul>
<li>$\alpha_1=0.0448$</li>
<li>$\alpha_2=0.2856$</li>
<li>$\alpha_3=0.3001$</li>
<li>$\alpha_4=0.2363$</li>
<li>$\alpha_5=0.1333$</li>
</ul>
<h2 id="MS-SSIM算法的实现"><a href="#MS-SSIM算法的实现" class="headerlink" title="MS-SSIM算法的实现"></a>MS-SSIM算法的实现</h2><p>采用FFMpeg中的$SSIM$的实现方式来实现$MS-SSIM$。根据<a href="/2020/02/15/how-to-calculate-the-SSIM-in-FFMpeg/">FFMpeg如何计算图像的SSIM</a>的介绍：</p>
<p>$$<br>MS-SSIM(X,Y)=\bigg(\frac{2s1 \cdot s2 + ssimC_{1}}{s1^2+s2^2+ssimC_{1}}\bigg)^{\alpha_{M}} \cdot \prod _{j=1}^{M}\bigg(\frac{2covar + ssimC_2}{vars + ssimC_2}\bigg)^{\alpha_j}<br>$$</p>
<p>对于图像采样而言，采用简单的$2 \times 2$的卷积核执行图像的下采样，：</p>
<p>$$<br>\begin{bmatrix}<br>\frac{1}{4} &amp; \frac{1}{4} \\<br>\frac{1}{4} &amp; \frac{1}{4} \\<br>\end{bmatrix}<br>$$</p>
<p>具体的采样代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void downsample_2x2_mean(pixel *input, int width, int height, pixel *output) &#123;</span><br><span class="line">    int downsample_width &#x3D;  width &gt;&gt; 1;</span><br><span class="line">    int downsample_height &#x3D; height &gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">    for (int y &#x3D; 0; y &lt; downsample_height; y++) &#123;</span><br><span class="line">        for (int x &#x3D;0; x &lt; downsample_width; x++) &#123;</span><br><span class="line">            output[y * downsample_width + x] &#x3D; (input[2 * y * width + 2 * x] +</span><br><span class="line">                                                input[2 * y * width + 2 * x + 1] +</span><br><span class="line">                                                input[(2 * y + 1) * width + 2 * x] +</span><br><span class="line">                                                input[(2 * y + 1) * width + 2 * x + 1]) &#x2F; 4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后利用<a href="https://github.com/FFmpeg/FFmpeg/blob/master/tests/tiny_ssim.c" target="_blank" rel="noopener">tiny_ssim</a>中的<code>ssim_plane()</code>迭代计算$MS-SSIM$。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float ms_ssim_plane(pixel *pix1, pixel *pix2, int width, int height, int scale) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; w * h; i++) &#123;</span><br><span class="line">        ori_img1[i] &#x3D; pix1[i];</span><br><span class="line">        ori_img2[i] &#x3D; pix2[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算每个尺度的ssim值.</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; scale; i++) &#123;</span><br><span class="line">        if (i !&#x3D; 1) &#123;</span><br><span class="line">            downsample_2x2_mean(ori_img1, w, h, sample_img1);</span><br><span class="line">            downsample_2x2_mean(ori_img2, w, h, sample_img2);</span><br><span class="line">            w &#x3D; w &gt;&gt; 1;</span><br><span class="line">            h &#x3D; h &gt;&gt; 1;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; w * h; j++) &#123;</span><br><span class="line">                ori_img1[j] &#x3D; sample_img1[j];</span><br><span class="line">                ori_img2[j] &#x3D; sample_img2[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        value &#x3D; ssim_plane(ori_img1, w, ori_img2, w, w, h, temp, NULL);</span><br><span class="line">        result *&#x3D; pow(value.C_S, WEIGHT[i-1]);</span><br><span class="line">        luminance_value[i-1] &#x3D; value.L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result *&#x3D; pow(luminance_value[scale-1], WEIGHT[scale-1]);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的代码可以参考<a href="https://github.com/wangwei1237/wangwei1237.github.io/blob/master/2020/02/25/how-to-calculate-the-MS-SSIM/test_msssim.cpp" target="_blank" rel="noopener">test_msssim.cpp</a>。代码的很大部分是由我的同事<em>贤杰</em>(github: <a href="https://github.com/bodhisatan" target="_blank" rel="noopener">@bodhisatan</a>)实现的，在此一并表示感谢。</p>
]]></content>
      <categories>
        <category>视频技术</category>
      </categories>
      <tags>
        <tag>SSIM</tag>
        <tag>MS-SSIM</tag>
      </tags>
  </entry>
  <entry>
    <title>The Proof of the ssim_end1() in FFMpeg</title>
    <url>/2020/02/18/the-proof-of-the-SSIM-in-FFMpeg/</url>
    <content><![CDATA[<p>$$<br>SSIM(a,b)=\frac{(2\mu_a\mu_b+C_1)(2\sigma_{ab}+C_2)}{(\mu_a^2+\mu_b^2+C_1)(\sigma_a^2+\sigma_b^2+C_2)}<br>$$</p>
<p>$$<br>\mu_a=\frac{1}{64}fs1<br>$$</p>
<a id="more"></a>

<p>$$<br>\mu_b=\frac{1}{64}fs2<br>$$</p>
<p>$$<br>\sigma_a^2+\sigma_b^2=\frac{1}{63}(\sum_{i,j}(a(i,j)-\mu_a)^2 + \sum_{i,j}(b(i,j)-\mu_b)^2)<br>$$</p>
<p>$$<br>=\frac{1}{63}\sum_{i,j}(a(i,j)^2+\mu_a^2-2 \cdot a(i,j) \cdot \mu_a+b(i,j)^2+\mu_b^2-2 \cdot b(i,j) \cdot \mu_b)<br>$$</p>
<p>$$<br>=\frac{1}{63}(\sum_{i,j}(a(i,j)^2+b(i,j)^2)-2(\mu_a\sum_{i,j}a(i,j)+\mu_b\sum_{i,j}b(i,j))+\sum_{i,j}<br>(\mu_a^2+\mu_b^2))<br>$$<br>$$<br>=\frac{1}{63}(fss-2 \cdot \frac{1}{64}(fs1^2+fs2^2)+\frac{1}{64}(fs1^2+fs2^2)<br>$$</p>
<p>$$<br>=\frac{1}{63}(fss-\frac{1}{64}(fs1^2+fs2^2))<br>$$</p>
<p>$$<br>=\frac{1}{63}\frac{1}{64}(64fss-fs1^2-fs2^2)<br>$$</p>
<p>$$<br>\sigma_{ab}=\frac{1}{63}\sum_{i,j}((a(i,j)-\mu_a)(b(i,j)-\mu_b))<br>$$</p>
<p>$$<br>=\frac{1}{63}\sum_{i,j}(a(i,j) \cdot b(i,j)-a(i,j)\mu_b-b(i,j)\mu_a+\mu_a \cdot \mu_b)<br>$$</p>
<p>$$<br>=\frac{1}{63}(fs12-fs1 \cdot \mu_b-fs2 \cdot \mu_a+fs1 \cdot \mu_b)<br>$$</p>
<p>$$<br>=\frac{1}{63}(fs12-\frac{1}{64}fs1 \cdot fs2)<br>$$</p>
<p>$$<br>=\frac{1}{63}\frac{1}{64}(64fs12-fs1 \cdot fs2)<br>$$</p>
<p>$$<br>\therefore SSIM(a,b)=\frac{(2fs1 \cdot fs2+64^2C_1)(2 \cdot 64fs12-2fs1fs2+63 \cdot 64C_2)}{(fs1^2+fs2^2+64^2C_1)(64fss-fs1^2-fs2^2+63 \cdot 64C_2)}<br>$$</p>
]]></content>
      <tags>
        <tag>FFMpeg</tag>
        <tag>SSIM</tag>
      </tags>
  </entry>
  <entry>
    <title>FFMpeg如何计算图像的SSIM</title>
    <url>/2020/02/15/how-to-calculate-the-SSIM-in-FFMpeg/</url>
    <content><![CDATA[<h2 id="SSIM基本概念"><a href="#SSIM基本概念" class="headerlink" title="SSIM基本概念"></a>SSIM基本概念</h2><p>关于$SSIM$的具体解释，此处不再介绍，具体可以参见<a href="https://wangwei1237.github.io/digital-video-concept/">数字视频相关概念</a>中的<a href="https://wangwei1237.github.io/digital-video-concept/docs/4_2_2_3_StructuralSimilarityBasedApproaches.html">SSIM算法</a>一节的介绍。</p>
<p>直接给出$SSIM$的计算方法：<br>$$<br>SSIM(x,y)=\frac{(2\mu_x\mu_y+C_1)(2\sigma_{xy}+C_2)}{(\mu_x^2+\mu_y^2+C_1)(\sigma_x^2+\sigma_y^2+C_2)}<br>$$</p>
<p>$C_1=(K_1L)^2, C_2=(K_2L)^2$。$K_1\ll1$，$K_2\ll1$均为常数，计算时，一般$K_1=0.01$，$K_2=0.03$。$L$是灰度的动态范围，由图像的数据类型决定，如果数据为<em>uint8</em>，则$L=255$。</p>
<a id="more"></a>

<h2 id="SSIM计算中的图像分割"><a href="#SSIM计算中的图像分割" class="headerlink" title="SSIM计算中的图像分割"></a>SSIM计算中的图像分割</h2><p>在整幅图片的跨度上，图像亮度的均值和方差变化较为剧烈；并且图像上不同区块的失真程度也有可能不同；再者人眼睛每次只能聚焦于一处，更关注局部数据而非全局数据。因此如上的$SSIM$算法不能直接作用于一整副图像。</p>
<p>在论文<strong>Image quality assessment: From error visibility to structural similarity</strong>中，作者采用$11 \times 11$的滑动窗口将整副图像分割为$N$个patch，然后计算每一个patch的$SSIM$，最后计算所有patch的$SSIM$值的平均数（$Mean \ \ SSIM:MSSIM$）作为整副图像的$SSIM$。为了避免滑动窗口带来的块效应，在计算每个patch的均值$\mu$和方差$\sigma^2$时，作者采用了$\sigma=1.5$的高斯卷积核作加权平均。</p>
<p>如果整副图像有$N$个patch，则$MSSIM$的计算方式为：</p>
<p>$$<br>MSSIM(X,Y) = \frac{1}{N}\sum_{i=1}^{N}{SSIM(x_i, y_i)}<br>$$</p>
<p>其中，$SSIM(x_i, y_i)$为第$i$个patch的$SSIM$。</p>
<h2 id="FFMpeg中计算SSIM的算法"><a href="#FFMpeg中计算SSIM的算法" class="headerlink" title="FFMpeg中计算SSIM的算法"></a>FFMpeg中计算SSIM的算法</h2><p>在FFMpeg中，也提供了计算$SSIM$的实现：<a href="https://github.com/FFmpeg/FFmpeg/blob/master/tests/tiny_ssim.c" target="_blank" rel="noopener">tiny_ssim</a>。从代码的注释中可以看到：为了提升算法的性能，没有采用论文中的高斯加权方式计算每个patch的$SSIM$，而是采用了一个$8 \times 8$的块来计算每个patch的$SSIM$。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * tiny_ssim.c</span><br><span class="line"> * Computes the Structural Similarity Metric between two rawYV12 video files.</span><br><span class="line"> * original algorithm:</span><br><span class="line"> * Z. Wang, A. C. Bovik, H. R. Sheikh and E. P. Simoncelli,</span><br><span class="line"> *   &quot;Image quality assessment: From error visibility to structural similarity,&quot;</span><br><span class="line"> *   IEEE Transactions on Image Processing, vol. 13, no. 4, pp. 600-612, Apr. 2004.</span><br><span class="line"> *</span><br><span class="line"> * To improve speed, this implementation uses the standard approximation of</span><br><span class="line"> * overlapped 8x8 block sums, rather than the original gaussian weights.</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="standard-approximation-of-overlapped-8x8-block-sums"><a href="#standard-approximation-of-overlapped-8x8-block-sums" class="headerlink" title="standard approximation of overlapped 8x8 block sums"></a>standard approximation of overlapped 8x8 block sums</h3><p>接下来就解释一下注释中的<em>standard approximation of overlapped 8x8 block sums</em>究竟是什么含义。在解释的过程中会分解成两个部分来解释：<em>overlapped 8x8 block</em>和<em>sums</em>。</p>
<h3 id="overlapped-8x8-block的含义"><a href="#overlapped-8x8-block的含义" class="headerlink" title="overlapped 8x8 block的含义"></a>overlapped 8x8 block的含义</h3><p>FFMpeg在计算图像$SSIM$时，首先以$4 \times 4$的块大小把<strong>图1</strong>所示的分辨率为$W \times H$的图像：<br><img src="/2020/02/15/how-to-calculate-the-SSIM-in-FFMpeg/1.jpg" alt="图1"><br>图1：原始图像</p>
<p>分割为<strong>图2</strong>的样式。<br><img src="/2020/02/15/how-to-calculate-the-SSIM-in-FFMpeg/2.jpg" alt="图2"></p>
<p>图2：分割后的图像</p>
<p>对于<strong>图2</strong>中的每一块用$block(i,j)$来表示（<em>图2中的红色块</em>），FFMpeg使用$block(i,j)$及其<strong>上、右、右上块</strong>（<em>图2中的绿色块</em>）来计算其$SSIM:SSIM(x_{ij},y_{ij})$。</p>
<p>$block(i,j)$及其<strong>上、右、右上块</strong>构成一个$8\times8$的像素块，并且该$8\times8$的块和计算$block(i,j+1)$的$SSIM$用到的$8\times8$的块存在重合像素，这就是注释中的<strong>overlapped 8x8 block</strong>的真正含义。</p>
<p>因此，根据如上规则：$i \in [1,\frac{H}{4}],j \in [0,\frac{W}{4}-1]$。也就是说：第0行和最后一列的块不会计算$SSIM$。</p>
<p>最后得到FFMpeg中的$SSIM$计算方式为：</p>
<p>$$<br>SSIM = MSSIM(X,Y) = \frac{1}{N}\sum_{i=1}^{\frac{H}{4}}\sum_{j=0}^{\frac{W}{4}-1}{SSIM(x_{ij}, y_{ij})}<br>$$</p>
<p>$$<br>N=(\frac{H}{4}-1)(\frac{W}{4}-1)<br>$$</p>
<h3 id="sums的含义"><a href="#sums的含义" class="headerlink" title="sums的含义"></a>sums的含义</h3><p>如前所述，我们分析了FFMpeg计算图像的$SSIM$的整体思路，接下来我们继续分析FFMpeg是如何计算$block(i,j)$的$SSIM(x_{ij},y_{ij})$的。</p>
<p>首先利用函数<code>ssim_4x4x2_core()</code>来计算$block(i,j)$块的结构相似性指标，主要是如下的4个指标：</p>
<ul>
<li><em>s1</em>：参考图像在$block(i,j)$块的像素之和</li>
<li><em>s2</em>：受损图像在$block(i,j)$块的像素之和</li>
<li><em>ss</em>：参考图像和受损图像在$block(i,j)$块的像素平方之和</li>
<li><em>s12</em>：参考图像和受损图像在$block(i,j)$块的对应像素乘积之和</li>
</ul>
<p>$s1=\sum_{i=0}^{3}\sum_{j=0}^{3}{x(i,j)}$<br>$s2=\sum_{i=0}^{3}\sum_{j=0}^{3}{y(i,j)}$<br>$ss=\sum_{i=0}^{3}\sum_{j=0}^{3}{\Big(\big(x(i,j)\big)^2+\big(y(i,j)\big)^2\Big)}$<br>$s12=\sum_{i=0}^{3}\sum_{j=0}^{3}{\big(x(i,j) \cdot y(i,j)\big)}$</p>
<p>如上的4个指标就是我们后续会用到的sums，该sums也就是<em>overlapped 8x8 block sums</em>中的<em>sums</em>的概念。</p>
<h3 id="利用sums计算各块的SSIM"><a href="#利用sums计算各块的SSIM" class="headerlink" title="利用sums计算各块的SSIM"></a>利用sums计算各块的SSIM</h3><p>接下来利用该sums值计算$SSIM$。</p>
<p>为了提升效率，FFMpeg会按照行来计算每一行的各个块的sums数据，并将每个行块的sums数据存储在长度为$\frac{W}{4}$的数组指针sum（<code>(int(*)[4])</code>）中。</p>
<p>其中sum指针有两种：</p>
<ul>
<li>sum0：存储当前行的各块的sums结果</li>
<li>sum1：存储当前行的上一行的sums结果</li>
</ul>
<p>先计算第$i-1$行块和第$i$行块的sums结果，并分别存入<code>sum1</code>和<code>sum0</code>中。然后遍历第$i$行块的每一个块，并利用<code>sum1</code>和<code>sum0</code>中计算的结果来计算每一块的$SSIM$。</p>
<p>函数<code>ssim_end4()</code>展示了如何利用$block(i-1,j)$，$block(i-1,j+1)$，$block(i,j)$，$block(i,j+1)$的sums信息来计算$SSIM(x_{ij},y_{ij})$：</p>
<ul>
<li>先对4个块的sums结果进行加和处理，得到$8\times8$块的sums结果</li>
<li>然后利用该$8\times8$块的sums来计算$block(i,j)$的$SSIM$</li>
</ul>
<p>函数<code>ssim_end1()</code>就展示了如何利用$8\times8$块的sums信息来计算$SSIM$。具体的计算方法如下。</p>
<p>将红色区块$block(i,j)$的图像放大一点，如图3所示。我们接下来计算其$SSIM$。<br><img src="/2020/02/15/how-to-calculate-the-SSIM-in-FFMpeg/3.jpg" alt="图3"><br>图3：<em>block(i,j)</em>的示意图</p>
<p>在计算时，首先将4个区块的sums值求和，得到$8\times8$区块的sums值，分别为：</p>
<ul>
<li>$s1=\sum_{i=0}^{63}{x_i}$</li>
<li>$s2=\sum_{i=0}^{63}{y_i}$</li>
<li>$ss=\sum_{i=0}^{63}{(x_i^2+y_i^2)}$</li>
<li>$s12=\sum_{i=0}^{63}{(x_i \cdot y_i)}$</li>
</ul>
<p>根据如上的计算，可以得到$\mu_x$，$\mu_y$，$\mu_x\mu_y$，$\mu_x^2+\mu_y^2$，$\sigma_x^2+\sigma_y^2$，$\sigma_{xy}$：</p>
<ul>
<li>$\mu_x=\frac{1}{64} \cdot s1$</li>
<li>$\mu_y=\frac{1}{64} \cdot s2$</li>
<li>$\mu_x\mu_y=\frac{1}{64 \cdot 64}(s1 \cdot s2)$</li>
<li>$\mu_x^2+\mu_y^2=\frac{1}{64 \cdot 64}\big((s1)^2+(s2)^2\big)$</li>
<li>$\sigma_x^2+\sigma_y^2=\frac{1}{64 \cdot 63}\big(64 \cdot ss-(s1)^2- (s2)^2\big)$</li>
<li>$\sigma_{xy}=\frac{1}{64 \cdot 63}(64 \cdot s12 - s1 \cdot s2)$</li>
</ul>
<p>利用如上的公式（具体推导可以参考<a href="/2020/02/18/the-proof-of-the-SSIM-in-FFMpeg/">ssim_end1()的推导</a>）对$SSIM$的公式进行计算可以得到：<br>$$<br>SSIM(x,y)=\frac{(2\mu_x\mu_y+C_1)(2\sigma_{xy}+C_2)}{(\mu_x^2+\mu_y^2+C_1)(\sigma_x^2+\sigma_y^2+C_2)}<br>$$</p>
<p>$$<br>=\frac{(2s1s2+64^2C_1)(2\cdot64s12-2s1s2+64\cdot63C_2)}{(s1^2+s2^2+64^2C_1)(64ss-s1^2-s2^2+64\cdot63C_2)}<br>$$</p>
<p>FFMpeg中，对$C_1$和$C_2$的定义中的因子<strong>64</strong>或<strong>63</strong>也是根据上面的公式，但是从公式看，<a href="https://trac.ffmpeg.org/ticket/8529" target="_blank" rel="noopener"><strong>FFMpeg对<code>ssim_c1</code>的计算少乘了64</strong></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssim_c1 &#x3D; 0.01 * 0.01 * 255 * 255 * 64 + 0.5</span><br><span class="line">ssim_c2 &#x3D; 0.03 * 0.03 * 255 * 255 * 64 * 63 + 0.5</span><br></pre></td></tr></table></figure>

<p>当然，为了简化处理，FFMpeg还做了如下的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vars  &#x3D; ss  * 64 - s1 * s1 - s2 * s2;</span><br><span class="line">covar &#x3D; s12 * 64 - s1 * s2;</span><br></pre></td></tr></table></figure>

<p>因此，最终在FFMpeg中，计算$SSIM$的公式为：</p>
<p>$$<br>SSIM(x,y)=\frac{(2s1s2+ssimC_1)(2covar+ssimC_2)}{(s1^2+s2^2+ssimC_1)(vars + ssimC_2)}<br>$$</p>
<p>如上的公式就是函数<code>ssim_end1()</code>中最终的计算方式。</p>
<h3 id="利用各块的SSIM计算图像的SSIM"><a href="#利用各块的SSIM计算图像的SSIM" class="headerlink" title="利用各块的SSIM计算图像的SSIM"></a>利用各块的SSIM计算图像的SSIM</h3><p>计算完所有块的$SSIM$之后，就可以计算所有块的平均$SSIM$并作为该图像的$SSIM$：</p>
<p>$$<br>SSIM(X,Y)= \frac{1}{N}\sum_{i=1}^{\frac{H}{4}}\sum_{j=0}^{\frac{W}{4}-1}{SSIM(x_{ij}, y_{ij})}<br>$$</p>
<p>$$<br>N=(\frac{H}{4}-1)(\frac{W}{4}-1)<br>$$</p>
<h3 id="编码过程中的技巧"><a href="#编码过程中的技巧" class="headerlink" title="编码过程中的技巧"></a>编码过程中的技巧</h3><p>在FFMpeg计算$SSIM$的算法实现中，为了提升效率和抽象代码逻辑，也利用了很多的编程技巧，例如：</p>
<ul>
<li>计算YUV各分量图像宽度时用<code>w &gt;&gt; !!i</code></li>
<li>为了避免对第0行的特殊处理，采用两层循环来处理</li>
<li>计算每一行的各块的sums信息时，为了降低循环次数，每次循环计算2个块的sums结果，<code>ssim_4x4x2_core</code>的函数名可能就是这么来的。</li>
<li>计算每一行的各块的$SSIM$时，为了降低循环次数，每次循环计算4个块的$SSIM$，<code>ssim_end4</code>的函数名可能就是这么来的。</li>
</ul>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>分析过程离不开和贤杰(github: <a href="https://github.com/bodhisatan" target="_blank" rel="noopener">@bodhisatan</a>)的不断讨论和交流，感谢@贤杰在繁忙的工作之余抽出时间来一起分析FFMpeg中SSIM算法的实现原理。</p>
]]></content>
      <categories>
        <category>视频技术</category>
      </categories>
      <tags>
        <tag>FFMpeg</tag>
        <tag>SSIM</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo-asset-image的图片地址错误问题</title>
    <url>/2020/02/05/handle-the-bug-of-hexo-asset-image-plugin/</url>
    <content><![CDATA[<p>由于<code>hexo-asset-image</code>插件存在bug，会导致博文中引用图片时无法生成正确的链接地址，进而导致图片无法访问的现象。<br>具体解决方案为将文件<code>node_modules/hexo-asset-image/index.js</code>替换为如下的内容：</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    	<span class="keyword">var</span> link = data.permalink;</span><br><span class="line">	<span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">	   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line">	<span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">			<span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">			<span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">			<span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">			   !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">			  <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">			  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">			  <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">				srcArray.shift();</span><br><span class="line">			  src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">			  $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">			  <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">			<span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo和github搭建个人博客</title>
    <url>/2020/02/05/use-hexo-and-github-for-blog/</url>
    <content><![CDATA[<h2 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h2><p>首先打开<a href="https://github.com/" target="_blank" rel="noopener">github</a>，点击<code>New repository</code>，创建一个新仓库用于存储博客的所有内容。</p>
<p>仓库名必须为：<code>账户名.github.io</code>，并且需要勾选<strong>Initialize this repository with a README</strong>。</p>
<p>在建好的仓库右侧有个<strong>settings</strong>按钮，点击<strong>settings</strong>，向下滑动到<strong>GitHub Pages</strong>，会发现有个网址，github会把该仓库中的项目部署到该网址下，该网址也是博客的默认地址。当然也可以购买域名，将其换成喜欢的地址。</p>
<a id="more"></a>

<p><img src="/2020/02/05/use-hexo-and-github-for-blog/1.jpg" alt></p>
<p><img src="/2020/02/05/use-hexo-and-github-for-blog/2.jpg" alt></p>
<h2 id="准备node-js环境"><a href="#准备node-js环境" class="headerlink" title="准备node.js环境"></a>准备node.js环境</h2><p>由于hexo是基于<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>开发的，因此在安装hexo之前，需要先安装node.js并配置响应的node.js环境。具体如下所示：</p>
<p><img src="/2020/02/05/use-hexo-and-github-for-blog/3.jpg" alt></p>
<h2 id="准备hexo环境"><a href="#准备hexo环境" class="headerlink" title="准备hexo环境"></a>准备hexo环境</h2><p>根据<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>的提示，安装hexo。具体如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ cd blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>此时hexo会在4000端口启动一个webserver，用浏览器访问<code>localhost:4000</code>则会看到初始化之后默认的站点。</p>
<h2 id="安装hexo插件"><a href="#安装hexo插件" class="headerlink" title="安装hexo插件"></a>安装hexo插件</h2><h3 id="hexo-generator-category"><a href="#hexo-generator-category" class="headerlink" title="hexo-generator-category"></a>hexo-generator-category</h3><p>该插件用于自动生成category，具体安装方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-category --save</span><br><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>然后修改<code>source/categories/index.md</code>的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-02-05 11:53:35</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="hexo-generator-tag"><a href="#hexo-generator-tag" class="headerlink" title="hexo-generator-tag"></a>hexo-generator-tag</h3><p>该插件用于自动生成tags，具体安装方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-tag --save</span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>然后修改<code>source/tags/index.md</code>的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-02-05 11:53:58</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="hexo-asset-image"><a href="#hexo-asset-image" class="headerlink" title="hexo-asset-image"></a>hexo-asset-image</h3><p>该插件主要用于解决在文章中引用图片的场景，具体安装方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>安装该插件后，利用<code>hexo new post &#39;test&#39;</code>生成新文章内容时，会在<code>source/_posts</code>目录下同时生成<code>test.md</code>和<code>test目录</code>，<code>test.md</code>中需要的图片可以存储在<code>test目录</code>下。在文档中，采用如下的方式来引用图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片的描述信息](1.jpg)</span><br></pre></td></tr></table></figure>

<p>关于hexo-asset-image生成图片的bug，可以参考文章：<a href="/2020/02/05/handle-the-bug-of-hexo-asset-image-plugin/">解决hexo-asset-image的图片地址错误问题</a></p>
<h3 id="hexo-deployer-git"><a href="#hexo-deployer-git" class="headerlink" title="hexo-deployer-git"></a>hexo-deployer-git</h3><p>该插件用于将编译后生成的站点内容发布到第一步创建的github仓库中，从而实现内容更新。具体安装方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm add hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>然后配置_config.yml中的<code>url</code>和<code>deploy</code>配置，以便可以通过该插件自动部署项目。具体配置如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://wangwei1237.github.io/</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/wangwei1237/wangwei1237.github.io</span></span><br></pre></td></tr></table></figure>

<p>配置完毕之后，如果项目内容发生修改，则利用如下的命令就可以完成自动发布：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>凡所过往，皆是序章</title>
    <url>/2020/02/05/where-of-what-is-past-is-prologue/</url>
    <content><![CDATA[<p>凡所过往，皆是序章，新的一年，用4个关键词来讲一讲2019年自己心中的过往和序章。</p>
<p><img src="/2020/02/05/where-of-what-is-past-is-prologue/1.jpg" alt></p>
<a id="more"></a>

<h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><p>如果要用1个词来形容2019年的话，我觉得就是 变化了。无论内部，还是外部，都在发生着翻天覆地的变化。变化这种滋味起初很痛苦，但是却蕴含着无限的机会。</p>
<p>未来，变化会是常态。工作方式要变，工具平台要变，开发语言要变……所有的事情都在向着好的方向变化、发展。</p>
<p>在这个变化的过程中，不能随波逐流，也不能固守己见。需要顺应变化，找到其中的机会，顺势而为，乘风而起。</p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>在快速的变化中，怎么才能乘风而起？秘诀也就是 学习了。</p>
<p>2019年，我学习了opengl，kotlin；</p>
<p>2019年，学习了数字视频，ffmpeg，opencv；</p>
<p>2019年，学习了Android的相机系统，学习了逆向破解；</p>
<p>2019年，学习了如何写作，学习了如何演讲，学习了如何系统化思考……</p>
<p>在学校的时候，为了工作而学习。现在或者未来，要为了学习而工作，不断学习新的技能。</p>
<p>学习是应对各种变化的不二法门。学习，在路上……</p>
<h2 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h2><p>创新这个词呢，总会和 造轮子这个词关联起来。</p>
<p>2019年， 造轮子这个词很频繁，频繁的有点令我不知所措。实际上，我个人不反对造轮子，但是反对 为了造轮子而造轮子。每种技术都有他的能力边界，在 造轮子的时候，要首先识别到能力的边界，然后找到一种快速有效的方式来解决我们的问题，这才是创新。</p>
<p>技术的进步就是一个造轮子的过程。为什么有了c++还会有java，有了java还会有kotlin？为什么有了苹果还会有安卓？为什么有了快手还会有抖音？……</p>
<p>未来，在创新的路上，需要更多的践行work smarter not work harder。</p>
<p><img src="/2020/02/05/where-of-what-is-past-is-prologue/2.jpg" alt></p>
<h2 id="突破"><a href="#突破" class="headerlink" title="突破"></a>突破</h2><p>毫无疑问，未来肯定是新人的天下。</p>
<p>未来需要更多的想，怎么能够让新人可以站在巨人的肩膀上成长；也要更多的想，怎们样才能够让自己成为人老心不老的老新人。</p>
<p>工作中，更无须给自己设限，这个我可能不行呢，那个我可能也搞不定呀，这个我没接触过呀，那个我没学过呀。怕什么呢，不试试怎们知道不行，不搞一搞怎么知道搞不定，没接触过就接触嘛，没学过就学起来嘛，没有什么大不了的。</p>
<p>工程师不就是要逢山开路遇水搭桥吗？要坚信，在我们可以想象的范围内，没有技术解决不了的问题。</p>
<p>冲破牢笼，方得始终。</p>
<p>加勒比海盗中有个桥段：</p>
<blockquote>
<p>船长：扬帆！起航！<br>水手：什么方向？<br>船长：海盗需要什么方向？起航！</p>
</blockquote>
<p>2020，扬帆，起航！乘着梦想之风，向着星光的方向，找到最好的自己。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>测试工作</tag>
      </tags>
  </entry>
  <entry>
    <title>对QA的思考——我的这些年</title>
    <url>/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/</url>
    <content><![CDATA[<p>2012年毕业后怀着一颗忐忑的心开始了测试工作的职业生涯，到现在也有7年啦。经历过奋斗和激情，也经历过徘徊和迷茫，勤恳却不庸碌。虽然对测试也有担忧，但是对这个行业始终保持着一种激情。</p>
<p>接下来结合自己的工作谈一下对测试的一些思考，也回顾下自己过去的测试工作中遵循的一些工作原则。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/1.jpg" alt></p>
<a id="more"></a>

<h2 id="原则1：正确的认识自己"><a href="#原则1：正确的认识自己" class="headerlink" title="原则1：正确的认识自己"></a>原则1：正确的认识自己</h2><p>好多人，自视甚高，傲视一切。但是，实际上，牛人很多。我们能做成一件事情，能力是一个方面，但能力绝对不是全部因素。没有上级的支持，没有同事的协作和配合，没有公司提供的资源，我们是什么事情也做不成的。不能因为自己的工作时间长，对业务了解的深，就对别人横加指责，也不能因为自己职称高就给别人以压力。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/2.png" alt></p>
<h2 id="原则2：先成就别人，再成就自己"><a href="#原则2：先成就别人，再成就自己" class="headerlink" title="原则2：先成就别人，再成就自己"></a>原则2：先成就别人，再成就自己</h2><p>我们经常问QA的价值是什么？</p>
<p>实际上有些东西是很难讲清楚的。好多QA为了证明自己的技术能力、技术价值，做了很多看似高超，但是实际上对业务快速迭代并没有用的事情。</p>
<p>我总觉得，自己的价值不是由自己体现的，而是由别人来体现的。只有先成就别人，才能最终成就自己。这就是我工作以来一直遵循的一个工作原则。不争，不抢，认真做事，认真帮别人做事，认真的帮业务做事情，帮助RD分析线上问题，解决BUG。到了后来，也颇有点：桃李不言，下自成蹊的味道。</p>
<p>好多人也会说，在这个时代，酒香也怕巷子深。如果不主动宣传自己的价值，宣传自己的影响力，别人是不会知道的。但是，实际上，影响力和价值是由别人来评估的，历史交由后人评就是这个道理。并且，影响力是处于某个圈层的，并通过圈层而扩散。我们首先在团队的圈层内做到影响力，才有可能通过圈层的扩散而扩散自己的价值。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/3.jpg" alt></p>
<h2 id="原则3：方便别人，方便自己"><a href="#原则3：方便别人，方便自己" class="headerlink" title="原则3：方便别人，方便自己"></a>原则3：方便别人，方便自己</h2><p>做测试的同学，每天会写很多测试case，每天也会发很多测试报告，但是如果打开这些邮件，经常发现这些case很难让人理解，这些测试报告虽然篇幅很大，但是如果要从中找到接下来RD要做什么，还是要花费一点时间的。</p>
<p>在测试工作过程中，无论是测试报告，还是风险通报，首先要了解到这些内容的接收者到底是谁，然后需要思考，要以什么样的描述和组织才能方便对方快速了解到内容的含义，也就是要做到：到什么山头，唱什么歌。</p>
<p>我刚入职的时候，因为之前没有做过测试，也不知道测试报告要以什么样的格式来发，所以很害怕发测试报告。虽然学习了其他前辈的测试报告和前辈们的测试报告范式，但是总感觉还是害怕。因为，从RD的角度来看，阅读那些测试报告的成本还是很大的。</p>
<p>然后，我站在RD的角度上想，怎么组织测试报告，才能让RD一眼就知道自己接下来要做什么呢？然后我重新组织了之前测测试报告，在报告的最开始用1句话概括项目的测试结论：该项目测试是否通过，原因是什么？具体的BUG量是多少？然后接下来是详细的测试清单，清单中明确表明每一个case的测试点，前置，预期结果，实际测试结果，是否通过等信息。对于测试通过的case，用绿色来标注；对于测试失败的case，用红色标注；对于有疑问的case，比如建议等，用黄色标注。RD收到测试报告之后，先看结论，然后看非绿色的测试case修复BUG。</p>
<h2 id="原则4：消除门槛，而不是提升门槛"><a href="#原则4：消除门槛，而不是提升门槛" class="headerlink" title="原则4：消除门槛，而不是提升门槛"></a>原则4：消除门槛，而不是提升门槛</h2><p>大禹治水之所以成功，最重要的思想就是：改“堵”为“疏”。</p>
<p>但是真正的测试过程中，经常会发现如下的现象：领导质疑QA的测试时间太长，QA质疑RD的提测质量太差，然后QA增加了准入打回的流程，对于RD提测的、没有通过准入的项目不予测试。</p>
<p>实际上，这种现象就是QA在项目的测试环节设置了一个门槛，而如果这种门槛设置的越来越多，那么对于业务而言也会发生“洪涝灾害”。单从测试团队的角度看，确实增加这个门槛，测试效率提升了，测试时间降低了，但是如果从整个业务的迭代来看，效率并没有提升。</p>
<p>我们提了门槛，发了准入case，增加了流程，这一点也不能说不好。但是我们有没有想过：这些准入case别人看的懂吗？我们怎么设计case能够使得RD自测的时候更加方便呢？即便看懂了，我们怎么保证RD确实执行了呢？我们怎么保证增加的这个流程每次都贯彻落实了呢？</p>
<p>QA不应该是一个门槛设置者，而应该是一种有效的武器。不能用看似合理的各种标准和要求卡住事情，而应该成为帮助团队解决问题的秘密武器。</p>
<p>QA不能只报问题，只说现象，只说RD不靠谱，上线不检查。QA需要思考：</p>
<ul>
<li>我们能为快速迭代做些什么？</li>
<li>我们能做些什么可以帮助RD快速发现自己的代码问题？</li>
<li>我们能做什么可以帮助RD快速发现上线过程异常了？</li>
</ul>
<h2 id="原则5：不断学习，不做伪学习者"><a href="#原则5：不断学习，不做伪学习者" class="headerlink" title="原则5：不断学习，不做伪学习者"></a>原则5：不断学习，不做伪学习者</h2><p>现在，技术更新换代的频率很快，所以一定要不断的学习，持续的学习。还记得刚入职的时候，那时候就会c/c++，java。现在看看自己的github和内网的提交记录，发现语言层面基本上涵盖了：c/c++，java，php，python，go，javascript，shell，object-c，swift，lua。项目类型覆盖了服务端，策略端，iOS，Android，自动化等不同的方向。从原来只会用IIS的小白，到今天了解Apache，Lighttpd，Nginx等各种web服务器。从原来的服务端，到慢慢了解前端，了解策略端，了解客户端。</p>
<p>参加过好多会，和好多人沟通过，大家都希望组织提供学习的机会，提供分享的机会，希望组织能提供自己技术成长的机会。但是，实际上，成长是自己的事，学习是个人的事，为什么要求组织给提供这些机会呢？我组织过很长时间的分享，我也最反对组织大规模的技术学习和分享，因为让太多的伪学习者进入之后，效果并不理想。相反，规模较小的沙龙和讨论对个人的技术成长效果更为明显。伪学习者只是想学习而已，只是想让组织提供学习机会而已，仅此而已。</p>
<p>学习是自己的事情，白天求生存，晚上求发展。凌晨2点的时候，也曾在灯下啃过Nginx的源码，分析一个个的线上问题，没有这些个凌晨2点就不会有《Nginx沉思录》，《Nginx洗冤录》等一系列的总结。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/4.jpg" alt></p>
<h2 id="原则6：做积极的抱怨者，不做消极的抱怨者"><a href="#原则6：做积极的抱怨者，不做消极的抱怨者" class="headerlink" title="原则6：做积极的抱怨者，不做消极的抱怨者"></a>原则6：做积极的抱怨者，不做消极的抱怨者</h2><p>没有“抱怨”就不会有技术的进步，但是反过来说没有“抱怨”就不会存在那么多的失败，一无是处，庸庸碌碌。关键是要看待我们对待“抱怨”的态度。当“抱怨”还仅仅是停留在嘴上，停留在思想上，被“抱怨”所控制时，基本上也就离碌碌无为不远了。当我们开始和“抱怨”对抗时，利用一切技术手段和努力消灭“抱怨”时，技术就开始进步了。所以，我一般不反对抱怨，并一直鼓励大家抱怨，但是接下来我会仔细分析抱怨的原因是什么？技术上需要什么探索才能消灭这些抱怨？</p>
<p>每一个“抱怨”都是一次机会，都是一个机遇，都是一次成长。逢山开路，遇水搭桥，勇往直前。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/5.jpg" alt></p>
<h2 id="原则7：正确认识QA和RD的异同"><a href="#原则7：正确认识QA和RD的异同" class="headerlink" title="原则7：正确认识QA和RD的异同"></a>原则7：正确认识QA和RD的异同</h2><p>天分日夜黑白，季节有春夏秋冬，虽然全栈模式有他的优点，但是四季也有四季的美。文能提笔安天下，武能上马定乾坤。关键是，我们需要对QA和RD有正确的认识。</p>
<p>我们不能按照一个原则来评定事情。比如：老驴拉磨，始终走不出那个圈圈。和日行千里的良马相比，当然老驴要羞愧了。但是如果换个角度，拉磨一天，产面千斤。良马再能跑，也跑不出千斤面。</p>
<p>QA和RD虽然都是研发岗，都是技术体系，那他们的差异在哪呢？</p>
<p>我觉得有以下几点吧：</p>
<ul>
<li>从工作关系上讲，QA是RD的下游，RD是QA的客户。</li>
<li>从工作重点上讲，QA注重分析，而RD注重实践。RD要做的是解决问题，采用任何可能的方法，快速实现需求，快速上线。而QA没有太大的业务压力，可以有更多的时间来思考每一种技术的优势和劣势，有更多的时间来仔细分析和追查每一个bug的深层原因，帮助RD在快速解决问题后可以彻底解决问题，锦上添花。</li>
<li>从涵盖业务上讲，QA关注的业务广度较高，而RD关注业务的深度更高。</li>
</ul>
<p>实际上，技术是一个很广泛的概念，不能认为只有写代码，设计架构才是技术，我们的思维本身就是一种技术。关键是，我们的技术要为业务的发展而存在，而不是孤立的存在。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/6.jpg" alt></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>测试工作</tag>
      </tags>
  </entry>
</search>
