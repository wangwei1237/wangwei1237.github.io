<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>The Proof of the ssim_end1() in FFMpeg</title>
    <url>/2020/02/18/the-proof-of-the-SSIM-in-FFMpeg/</url>
    <content><![CDATA[<p>$$<br>SSIM(a,b)=\frac{(2\mu_a\mu_b+C_1)(2\sigma_{ab}+C_2)}{(\mu_a^2+\mu_b^2+C_1)(\sigma_a^2+\sigma_b^2+C_2)}<br>$$</p>
<p>$$<br>\mu_a=\frac{1}{64}fs1<br>$$</p>
<a id="more"></a>

<p>$$<br>\mu_b=\frac{1}{64}fs2<br>$$</p>
<p>$$<br>\sigma_a^2+\sigma_b^2=\frac{1}{63}(\sum_{i,j}(a(i,j)-\mu_a)^2 + \sum_{i,j}(b(i,j)-\mu_b)^2)<br>$$</p>
<p>$$<br>=\frac{1}{63}\sum_{i,j}(a(i,j)^2+\mu_a^2-2 \cdot a(i,j) \cdot \mu_a+b(i,j)^2+\mu_b^2-2 \cdot b(i,j) \cdot \mu_b)<br>$$</p>
<p>$$<br>=\frac{1}{63}(\sum_{i,j}(a(i,j)^2+b(i,j)^2)-2(\mu_a\sum_{i,j}a(i,j)+\mu_b\sum_{i,j}b(i,j))+\sum_{i,j}<br>(\mu_a^2+\mu_b^2))<br>$$<br>$$<br>=\frac{1}{63}(fss-2 \cdot \frac{1}{64}(fs1^2+fs2^2)+\frac{1}{64}(fs1^2+fs2^2)<br>$$</p>
<p>$$<br>=\frac{1}{63}(fss-\frac{1}{64}(fs1^2+fs2^2))<br>$$</p>
<p>$$<br>=\frac{1}{63}\frac{1}{64}(64fss-fs1^2-fs2^2)<br>$$</p>
<p>$$<br>\sigma_{ab}=\frac{1}{63}\sum_{i,j}((a(i,j)-\mu_a)(b(i,j)-\mu_b))<br>$$</p>
<p>$$<br>=\frac{1}{63}\sum_{i,j}(a(i,j) \cdot b(i,j)-a(i,j)\mu_b-b(i,j)\mu_a+\mu_a \cdot \mu_b)<br>$$</p>
<p>$$<br>=\frac{1}{63}(fs12-fs1 \cdot \mu_b-fs2 \cdot \mu_a+fs1 \cdot \mu_b)<br>$$</p>
<p>$$<br>=\frac{1}{63}(fs12-\frac{1}{64}fs1 \cdot fs2)<br>$$</p>
<p>$$<br>=\frac{1}{63}\frac{1}{64}(64fs12-fs1 \cdot fs2)<br>$$</p>
<p>$$<br>\therefore SSIM(a,b)=\frac{(2fs1 \cdot fs2+64^2C_1)(2 \cdot 64fs12-2fs1fs2+63 \cdot 64C_2)}{(fs1^2+fs2^2+64^2C_1)(64fss-fs1^2-fs2^2+63 \cdot 64C_2)}<br>$$</p>
]]></content>
  </entry>
  <entry>
    <title>FFMpeg如何计算图像的SSIM</title>
    <url>/2020/02/15/how-to-calculate-the-SSIM-in-FFMpeg/</url>
    <content><![CDATA[<h2 id="SSIM基本概念"><a href="#SSIM基本概念" class="headerlink" title="SSIM基本概念"></a>SSIM基本概念</h2><p>关于$SSIM$的具体解释，此处不再介绍，具体可以参见：<a href="https://wangwei1237.gitbook.io/digital_video_concepts/shi-pin-zhi-liang-du-liang/4_2_0_videoqualityevaluationmethodsandmetrics/4_2_2_0_objectivevideoqualityevaluationmethodsandmetrics/4_2_2_3_structuralsimilaritybasedapproaches" target="_blank" rel="noopener">SSIM算法</a>。</p>
<p>直接给出$SSIM$的计算方法：<br>$$<br>SSIM(x,y)=\frac{(2\mu_x\mu_y+C_1)(2\sigma_{xy}+C_2)}{(\mu_x^2+\mu_y^2+C_1)(\sigma_x^2+\sigma_y^2+C_2)}<br>$$</p>
<p>$C_1=(K_1L)^2, C_2=(K_2L)^2$。$K_1\ll1$，$K_2\ll1$均为常数，计算时，一般$K_1=0.01$，$K_2=0.03$。$L$是灰度的动态范围，由图像的数据类型决定，如果数据为<em>uint8</em>，则$L=255$。</p>
<a id="more"></a>

<h2 id="SSIM计算中的图像分割"><a href="#SSIM计算中的图像分割" class="headerlink" title="SSIM计算中的图像分割"></a>SSIM计算中的图像分割</h2><p>在整幅图片的跨度上，图像亮度的均值和方差变化较为剧烈；并且图像上不同区块的失真程度也有可能不同；再者人眼睛每次只能聚焦于一处，更关注局部数据而非全局数据。因此如上的$SSIM$算法不能直接作用于一整副图像。</p>
<p>在论文<strong>Image quality assessment: From error visibility to structural similarity</strong>中，作者采用$11 \times 11$的滑动窗口将整副图像分割为$N$个patch，然后计算每一个patch的$SSIM$，最后计算所有patch的$SSIM$值的平均数（$Mean \ \ SSIM:MSSIM$）作为整副图像的$SSIM$。为了避免滑动窗口带来的块效应，在计算每个patch的均值$\mu$和方差$\sigma^2$时，作者采用了$\sigma=1.5$的高斯卷积核作加权平均。</p>
<p>如果整副图像有$N$个patch，则$MSSIM$的计算方式为：</p>
<p>$$<br>MSSIM(X,Y) = \frac{1}{N}\sum_{i=1}^{N}{SSIM(x_i, y_i)}<br>$$</p>
<p>其中，$SSIM(x_i, y_i)$为第$i$个patch的$SSIM$。</p>
<h2 id="FFMpeg中计算SSIM的算法"><a href="#FFMpeg中计算SSIM的算法" class="headerlink" title="FFMpeg中计算SSIM的算法"></a>FFMpeg中计算SSIM的算法</h2><p>在FFMpeg中，也提供了计算$SSIM$的实现：<a href="https://github.com/FFmpeg/FFmpeg/blob/master/tests/tiny_ssim.c" target="_blank" rel="noopener">tiny_ssim</a>。从代码的注释中可以看到：为了提升算法的性能，没有采用论文中的高斯加权方式计算每个patch的$SSIM$，而是采用了一个$8 \times 8$的块来计算每个patch的$SSIM$。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * tiny_ssim.c</span><br><span class="line"> * Computes the Structural Similarity Metric between two rawYV12 video files.</span><br><span class="line"> * original algorithm:</span><br><span class="line"> * Z. Wang, A. C. Bovik, H. R. Sheikh and E. P. Simoncelli,</span><br><span class="line"> *   &quot;Image quality assessment: From error visibility to structural similarity,&quot;</span><br><span class="line"> *   IEEE Transactions on Image Processing, vol. 13, no. 4, pp. 600-612, Apr. 2004.</span><br><span class="line"> *</span><br><span class="line"> * To improve speed, this implementation uses the standard approximation of</span><br><span class="line"> * overlapped 8x8 block sums, rather than the original gaussian weights.</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="standard-approximation-of-overlapped-8x8-block-sums"><a href="#standard-approximation-of-overlapped-8x8-block-sums" class="headerlink" title="standard approximation of overlapped 8x8 block sums"></a>standard approximation of overlapped 8x8 block sums</h3><p>接下来就解释一下注释中的<em>standard approximation of overlapped 8x8 block sums</em>究竟是什么含义。在解释的过程中会分解成两个部分来解释：<em>overlapped 8x8 block</em>和<em>sums</em>。</p>
<h3 id="overlapped-8x8-block的含义"><a href="#overlapped-8x8-block的含义" class="headerlink" title="overlapped 8x8 block的含义"></a>overlapped 8x8 block的含义</h3><p>FFMpeg在计算图像$SSIM$时，首先以$4 \times 4$的块大小把<strong>图1</strong>所示的分辨率为$W \times H$的图像：<br><img src="/2020/02/15/how-to-calculate-the-SSIM-in-FFMpeg/1.jpg" alt="图1"><br>图1：原始图像</p>
<p>分割为<strong>图2</strong>的样式。<br><img src="/2020/02/15/how-to-calculate-the-SSIM-in-FFMpeg/2.jpg" alt="图2"></p>
<p>图2：分割后的图像</p>
<p>对于<strong>图2</strong>中的每一块用$block(i,j)$来表示（<em>图2中的红色块</em>），FFMpeg使用$block(i,j)$及其<strong>上、右、右上块</strong>（<em>图2中的绿色块</em>）来计算其$SSIM:SSIM(x_{ij},y_{ij})$。</p>
<p>$block(i,j)$及其<strong>上、右、右上块</strong>构成一个$8\times8$的像素块，并且该$8\times8$的块和计算$block(i,j+1)$的$SSIM$用到的$8\times8$的块存在重合像素，这就是注释中的<strong>overlapped 8x8 block</strong>的真正含义。</p>
<p>因此，根据如上规则：$i \in [1,\frac{H}{4}],j \in [0,\frac{W}{4}-1]$。也就是说：第0行和最后一列的块不会计算$SSIM$。</p>
<p>最后得到FFMpeg中的$SSIM$计算方式为：</p>
<p>$$<br>SSIM = MSSIM(X,Y) = \frac{1}{N}\sum_{i=1}^{\frac{H}{4}}\sum_{j=0}^{\frac{W}{4}-1}{SSIM(x_{ij}, y_{ij})}<br>$$</p>
<p>$$<br>N=(\frac{H}{4}-1)(\frac{W}{4}-1)<br>$$</p>
<h3 id="sums的含义"><a href="#sums的含义" class="headerlink" title="sums的含义"></a>sums的含义</h3><p>如前所述，我们分析了FFMpeg计算图像的$SSIM$的整体思路，接下来我们继续分析FFMpeg是如何计算$block(i,j)$的$SSIM(x_{ij},y_{ij})$的。</p>
<p>首先利用函数<code>ssim_4x4x2_core()</code>来计算$block(i,j)$块的结构相似性指标，主要是如下的4个指标：</p>
<ul>
<li><em>s1</em>：参考图像在$block(i,j)$块的像素之和</li>
<li><em>s2</em>：受损图像在$block(i,j)$块的像素之和</li>
<li><em>ss</em>：参考图像和受损图像在$block(i,j)$块的像素平方之和</li>
<li><em>s12</em>：参考图像和受损图像在$block(i,j)$块的对应像素乘积之和</li>
</ul>
<p>$s1=\sum_{i=0}^{3}\sum_{j=0}^{3}{x(i,j)}$<br>$s2=\sum_{i=0}^{3}\sum_{j=0}^{3}{y(i,j)}$<br>$ss=\sum_{i=0}^{3}\sum_{j=0}^{3}{\Big(\big(x(i,j)\big)^2+\big(y(i,j)\big)^2\Big)}$<br>$s12=\sum_{i=0}^{3}\sum_{j=0}^{3}{\big(x(i,j) \cdot y(i,j)\big)}$</p>
<p>如上的4个指标就是我们后续会用到的sums，该sums也就是<em>overlapped 8x8 block sums</em>中的<em>sums</em>的概念。</p>
<h3 id="利用sums计算各块的SSIM"><a href="#利用sums计算各块的SSIM" class="headerlink" title="利用sums计算各块的SSIM"></a>利用sums计算各块的SSIM</h3><p>接下来利用该sums值计算$SSIM$。</p>
<p>为了提升效率，FFMpeg会按照行来计算每一行的各个块的sums数据，并将每个行块的sums数据存储在长度为$\frac{W}{4}$的数组指针sum（<code>(int(*)[4])</code>）中。</p>
<p>其中sum指针有两种：</p>
<ul>
<li>sum0：存储当前行的各块的sums结果</li>
<li>sum1：存储当前行的上一行的sums结果</li>
</ul>
<p>先计算第$i-1$行块和第$i$行块的sums结果，并分别存入<code>sum1</code>和<code>sum0</code>中。然后遍历第$i$行块的每一个块，并利用<code>sum1</code>和<code>sum0</code>中计算的结果来计算每一块的$SSIM$。</p>
<p>函数<code>ssim_end4()</code>展示了如何利用$block(i-1,j)$，$block(i-1,j+1)$，$block(i,j)$，$block(i,j+1)$的sums信息来计算$SSIM(x_{ij},y_{ij})$：</p>
<ul>
<li>先对4个块的sums结果进行加和处理，得到$8\times8$块的sums结果</li>
<li>然后利用该$8\times8$块的sums来计算$block(i,j)$的$SSIM$</li>
</ul>
<p>函数<code>ssim_end1()</code>就展示了如何利用$8\times8$块的sums信息来计算$SSIM$。具体的计算方法如下。</p>
<p>将红色区块$block(i,j)$的图像放大一点，如图3所示。我们接下来计算其$SSIM$。<br><img src="/2020/02/15/how-to-calculate-the-SSIM-in-FFMpeg/3.jpg" alt="图3"><br>图3：<em>block(i,j)</em>的示意图</p>
<p>在计算时，首先将4个区块的sums值求和，得到$8\times8$区块的sums值，分别为：</p>
<ul>
<li>$s1=\sum_{i=0}^{63}{x_i}$</li>
<li>$s2=\sum_{i=0}^{63}{y_i}$</li>
<li>$ss=\sum_{i=0}^{63}{(x_i^2+y_i^2)}$</li>
<li>$s12=\sum_{i=0}^{63}{(x_i \cdot y_i)}$</li>
</ul>
<p>根据如上的计算，可以得到$\mu_x$，$\mu_y$，$\mu_x\mu_y$，$\mu_x^2+\mu_y^2$，$\sigma_x^2+\sigma_y^2$，$\sigma_{xy}$：</p>
<ul>
<li>$\mu_x=\frac{1}{64} \cdot s1$</li>
<li>$\mu_y=\frac{1}{64} \cdot s2$</li>
<li>$\mu_x\mu_y=\frac{1}{64 \cdot 64}(s1 \cdot s2)$</li>
<li>$\mu_x^2+\mu_y^2=\frac{1}{64 \cdot 64}\big((s1)^2+(s2)^2\big)$</li>
<li>$\sigma_x^2+\sigma_y^2=\frac{1}{64 \cdot 63}\big(64 \cdot ss-(s1)^2- (s2)^2\big)$</li>
<li>$\sigma_{xy}=\frac{1}{64 \cdot 63}(64 \cdot s12 - s1 \cdot s2)$</li>
</ul>
<p>利用如上的公式（具体推导可以参考<a href="/2020/02/18/the-proof-of-the-SSIM-in-FFMpeg/">ssim_end1()的推导</a>）对$SSIM$的公式进行计算可以得到：<br>$$<br>SSIM(x,y)=\frac{(2\mu_x\mu_y+C_1)(2\sigma_{xy}+C_2)}{(\mu_x^2+\mu_y^2+C_1)(\sigma_x^2+\sigma_y^2+C_2)}<br>$$</p>
<p>$$<br>=\frac{(2s1s2+64^2C_1)(2\cdot64s12-2s1s2+64\cdot63C_2)}{(s1^2+s2^2+64^2C_1)(64ss-s1^2-s2^2+64\cdot63C_2)}<br>$$</p>
<p>FFMpeg中，对$C_1$和$C_2$的定义中的因子<strong>64</strong>或<strong>63</strong>也是根据上面的公式，但是从公式看，<a href="https://trac.ffmpeg.org/ticket/8529" target="_blank" rel="noopener"><strong>FFMpeg对<code>ssim_c1</code>的计算少乘了64</strong></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssim_c1 &#x3D; 0.01 * 0.01 * 255 * 255 * 64 + 0.5</span><br><span class="line">ssim_c2 &#x3D; 0.03 * 0.03 * 255 * 255 * 64 * 63 + 0.5</span><br></pre></td></tr></table></figure>

<p>当然，为了简化处理，FFMpeg还做了如下的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vars  &#x3D; ss  * 64 - s1 * s1 - s2 * s2;</span><br><span class="line">covar &#x3D; s12 * 64 - s1 * s2;</span><br></pre></td></tr></table></figure>

<p>因此，最终在FFMpeg中，计算$SSIM$的公式为：</p>
<p>$$<br>SSIM(x,y)=\frac{(2s1s2+ssimC_1)(2covar+ssimC_2)}{(s1^2+s2^2+ssimC_1)(vars + ssimC_2)}<br>$$</p>
<p>如上的公式就是函数<code>ssim_end1()</code>中最终的计算方式。</p>
<h3 id="利用各块的SSIM计算图像的SSIM"><a href="#利用各块的SSIM计算图像的SSIM" class="headerlink" title="利用各块的SSIM计算图像的SSIM"></a>利用各块的SSIM计算图像的SSIM</h3><p>计算完所有块的$SSIM$之后，就可以计算所有块的平均$SSIM$并作为该图像的$SSIM$：</p>
<p>$$<br>SSIM(X,Y)= \frac{1}{N}\sum_{i=1}^{\frac{H}{4}}\sum_{j=0}^{\frac{W}{4}-1}{SSIM(x_{ij}, y_{ij})}<br>$$</p>
<p>$$<br>N=(\frac{H}{4}-1)(\frac{W}{4}-1)<br>$$</p>
<h3 id="编码过程中的技巧"><a href="#编码过程中的技巧" class="headerlink" title="编码过程中的技巧"></a>编码过程中的技巧</h3><p>在FFMpeg计算$SSIM$的算法实现中，为了提升效率和抽象代码逻辑，也利用了很多的编程技巧，例如：</p>
<ul>
<li>计算YUV各分量图像宽度时用<code>w &gt;&gt; !!i</code></li>
<li>为了避免对第0行的特殊处理，采用两层循环来处理</li>
<li>计算每一行的各块的sums信息时，为了降低循环次数，每次循环计算2个块的sums结果，<code>ssim_4x4x2_core</code>的函数名可能就是这么来的。</li>
<li>计算每一行的各块的$SSIM$时，为了降低循环次数，每次循环计算4个块的$SSIM$，<code>ssim_end4</code>的函数名可能就是这么来的。</li>
</ul>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>分析过程离不开和贤杰(github: <a href="https://github.com/bodhisatan" target="_blank" rel="noopener">@bodhisatan</a>)的不断讨论和交流，感谢@贤杰在繁忙的工作之余抽出时间来一起分析FFMpeg中SSIM算法的实现原理。</p>
]]></content>
      <categories>
        <category>视频技术</category>
      </categories>
      <tags>
        <tag>SSIM</tag>
        <tag>FFMpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo-asset-image的图片地址错误问题</title>
    <url>/2020/02/05/handle-the-bug-of-hexo-asset-image-plugin/</url>
    <content><![CDATA[<p>由于<code>hexo-asset-image</code>插件存在bug，会导致博文中引用图片时无法生成正确的链接地址，进而导致图片无法访问的现象。<br>具体解决方案为将文件<code>node_modules/hexo-asset-image/index.js</code>替换为如下的内容：</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    	<span class="keyword">var</span> link = data.permalink;</span><br><span class="line">	<span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">	   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line">	<span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">			<span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">			<span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">			<span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">			   !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">			  <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">			  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">			  <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">				srcArray.shift();</span><br><span class="line">			  src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">			  $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">			  <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">			<span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo和github搭建个人博客</title>
    <url>/2020/02/05/use-hexo-and-github-for-blog/</url>
    <content><![CDATA[<h2 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h2><p>首先打开<a href="https://github.com/" target="_blank" rel="noopener">github</a>，点击<code>New repository</code>，创建一个新仓库用于存储博客的所有内容。</p>
<p>仓库名必须为：<code>账户名.github.io</code>，并且需要勾选<strong>Initialize this repository with a README</strong>。</p>
<p>在建好的仓库右侧有个<strong>settings</strong>按钮，点击<strong>settings</strong>，向下滑动到<strong>GitHub Pages</strong>，会发现有个网址，github会把该仓库中的项目部署到该网址下，该网址也是博客的默认地址。当然也可以购买域名，将其换成喜欢的地址。</p>
<p><img src="/2020/02/05/use-hexo-and-github-for-blog/1.jpg" alt></p>
<p><img src="/2020/02/05/use-hexo-and-github-for-blog/2.jpg" alt></p>
<a id="more"></a>

<h2 id="准备node-js环境"><a href="#准备node-js环境" class="headerlink" title="准备node.js环境"></a>准备node.js环境</h2><p>由于hexo是基于<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>开发的，因此在安装hexo之前，需要先安装node.js并配置响应的node.js环境。具体如下所示：</p>
<p><img src="/2020/02/05/use-hexo-and-github-for-blog/3.jpg" alt></p>
<h2 id="准备hexo环境"><a href="#准备hexo环境" class="headerlink" title="准备hexo环境"></a>准备hexo环境</h2><p>根据<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>的提示，安装hexo。具体如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ cd blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>此时hexo会在4000端口启动一个webserver，用浏览器访问<code>localhost:4000</code>则会看到初始化之后默认的站点。</p>
<h2 id="安装hexo插件"><a href="#安装hexo插件" class="headerlink" title="安装hexo插件"></a>安装hexo插件</h2><h3 id="hexo-generator-category"><a href="#hexo-generator-category" class="headerlink" title="hexo-generator-category"></a>hexo-generator-category</h3><p>该插件用于自动生成category，具体安装方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-category --save</span><br><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>然后修改<code>source/categories/index.md</code>的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-02-05 11:53:35</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="hexo-generator-tag"><a href="#hexo-generator-tag" class="headerlink" title="hexo-generator-tag"></a>hexo-generator-tag</h3><p>该插件用于自动生成tags，具体安装方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-tag --save</span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>然后修改<code>source/tags/index.md</code>的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-02-05 11:53:58</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="hexo-asset-image"><a href="#hexo-asset-image" class="headerlink" title="hexo-asset-image"></a>hexo-asset-image</h3><p>该插件主要用于解决在文章中引用图片的场景，具体安装方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>安装该插件后，利用<code>hexo new post &#39;test&#39;</code>生成新文章内容时，会在<code>source/_posts</code>目录下同时生成<code>test.md</code>和<code>test目录</code>，<code>test.md</code>中需要的图片可以存储在<code>test目录</code>下。在文档中，采用如下的方式来引用图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片的描述信息](1.jpg)</span><br></pre></td></tr></table></figure>

<p>关于hexo-asset-image生成图片的bug，可以参考文章：<a href="/2020/02/05/handle-the-bug-of-hexo-asset-image-plugin/">解决hexo-asset-image的图片地址错误问题</a></p>
<h3 id="hexo-deployer-git"><a href="#hexo-deployer-git" class="headerlink" title="hexo-deployer-git"></a>hexo-deployer-git</h3><p>该插件用于将编译后生成的站点内容发布到第一步创建的github仓库中，从而实现内容更新。具体安装方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm add hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>然后配置_config.yml中的<code>url</code>和<code>deploy</code>配置，以便可以通过该插件自动部署项目。具体配置如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://wangwei1237.github.io/</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/wangwei1237/wangwei1237.github.io</span></span><br></pre></td></tr></table></figure>

<p>配置完毕之后，如果项目内容发生修改，则利用如下的命令就可以完成自动发布：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>凡所过往，皆是序章</title>
    <url>/2020/02/05/where-of-what-is-past-is-prologue/</url>
    <content><![CDATA[<p>凡所过往，皆是序章，新的一年，用4个关键词来讲一讲2019年自己心中的过往和序章。</p>
<p><img src="/2020/02/05/where-of-what-is-past-is-prologue/1.jpg" alt></p>
<a id="more"></a>

<h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><p>如果要用1个词来形容2019年的话，我觉得就是 变化了。无论内部，还是外部，都在发生着翻天覆地的变化。变化这种滋味起初很痛苦，但是却蕴含着无限的机会。</p>
<p>未来，变化会是常态。工作方式要变，工具平台要变，开发语言要变……所有的事情都在向着好的方向变化、发展。</p>
<p>在这个变化的过程中，不能随波逐流，也不能固守己见。需要顺应变化，找到其中的机会，顺势而为，乘风而起。</p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>在快速的变化中，怎么才能乘风而起？秘诀也就是 学习了。</p>
<p>2019年，我学习了opengl，kotlin；</p>
<p>2019年，学习了数字视频，ffmpeg，opencv；</p>
<p>2019年，学习了Android的相机系统，学习了逆向破解；</p>
<p>2019年，学习了如何写作，学习了如何演讲，学习了如何系统化思考……</p>
<p>在学校的时候，为了工作而学习。现在或者未来，要为了学习而工作，不断学习新的技能。</p>
<p>学习是应对各种变化的不二法门。学习，在路上……</p>
<h2 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h2><p>创新这个词呢，总会和 造轮子这个词关联起来。</p>
<p>2019年， 造轮子这个词很频繁，频繁的有点令我不知所措。实际上，我个人不反对造轮子，但是反对 为了造轮子而造轮子。每种技术都有他的能力边界，在 造轮子的时候，要首先识别到能力的边界，然后找到一种快速有效的方式来解决我们的问题，这才是创新。</p>
<p>技术的进步就是一个造轮子的过程。为什么有了c++还会有java，有了java还会有kotlin？为什么有了苹果还会有安卓？为什么有了快手还会有抖音？……</p>
<p>未来，在创新的路上，需要更多的践行work smarter not work harder。</p>
<p><img src="/2020/02/05/where-of-what-is-past-is-prologue/2.jpg" alt></p>
<h2 id="突破"><a href="#突破" class="headerlink" title="突破"></a>突破</h2><p>毫无疑问，未来肯定是新人的天下。</p>
<p>未来需要更多的想，怎么能够让新人可以站在巨人的肩膀上成长；也要更多的想，怎们样才能够让自己成为人老心不老的老新人。</p>
<p>工作中，更无须给自己设限，这个我可能不行呢，那个我可能也搞不定呀，这个我没接触过呀，那个我没学过呀。怕什么呢，不试试怎们知道不行，不搞一搞怎么知道搞不定，没接触过就接触嘛，没学过就学起来嘛，没有什么大不了的。</p>
<p>工程师不就是要逢山开路遇水搭桥吗？要坚信，在我们可以想象的范围内，没有技术解决不了的问题。</p>
<p>冲破牢笼，方得始终。</p>
<p>加勒比海盗中有个桥段：</p>
<blockquote>
<p>船长：扬帆！起航！<br>水手：什么方向？<br>船长：海盗需要什么方向？起航！</p>
</blockquote>
<p>2020，扬帆，起航！乘着梦想之风，向着星光的方向，找到最好的自己。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>测试工作</tag>
      </tags>
  </entry>
  <entry>
    <title>对QA的思考——我的这些年</title>
    <url>/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/</url>
    <content><![CDATA[<p>2012年毕业后怀着一颗忐忑的心开始了测试工作的职业生涯，到现在也有7年啦。经历过奋斗和激情，也经历过徘徊和迷茫，勤恳却不庸碌。虽然对测试也有担忧，但是对这个行业始终保持着一种激情。</p>
<p>接下来结合自己的工作谈一下对测试的一些思考，也回顾下自己过去的测试工作中遵循的一些工作原则。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/1.jpg" alt></p>
<a id="more"></a>

<h2 id="原则1：正确的认识自己"><a href="#原则1：正确的认识自己" class="headerlink" title="原则1：正确的认识自己"></a>原则1：正确的认识自己</h2><p>好多人，自视甚高，傲视一切。但是，实际上，牛人很多。我们能做成一件事情，能力是一个方面，但能力绝对不是全部因素。没有上级的支持，没有同事的协作和配合，没有公司提供的资源，我们是什么事情也做不成的。不能因为自己的工作时间长，对业务了解的深，就对别人横加指责，也不能因为自己职称高就给别人以压力。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/2.png" alt></p>
<h2 id="原则2：先成就别人，再成就自己"><a href="#原则2：先成就别人，再成就自己" class="headerlink" title="原则2：先成就别人，再成就自己"></a>原则2：先成就别人，再成就自己</h2><p>我们经常问QA的价值是什么？</p>
<p>实际上有些东西是很难讲清楚的。好多QA为了证明自己的技术能力、技术价值，做了很多看似高超，但是实际上对业务快速迭代并没有用的事情。</p>
<p>我总觉得，自己的价值不是由自己体现的，而是由别人来体现的。只有先成就别人，才能最终成就自己。这就是我工作以来一直遵循的一个工作原则。不争，不抢，认真做事，认真帮别人做事，认真的帮业务做事情，帮助RD分析线上问题，解决BUG。到了后来，也颇有点：桃李不言，下自成蹊的味道。</p>
<p>好多人也会说，在这个时代，酒香也怕巷子深。如果不主动宣传自己的价值，宣传自己的影响力，别人是不会知道的。但是，实际上，影响力和价值是由别人来评估的，历史交由后人评就是这个道理。并且，影响力是处于某个圈层的，并通过圈层而扩散。我们首先在团队的圈层内做到影响力，才有可能通过圈层的扩散而扩散自己的价值。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/3.jpg" alt></p>
<h2 id="原则3：方便别人，方便自己"><a href="#原则3：方便别人，方便自己" class="headerlink" title="原则3：方便别人，方便自己"></a>原则3：方便别人，方便自己</h2><p>做测试的同学，每天会写很多测试case，每天也会发很多测试报告，但是如果打开这些邮件，经常发现这些case很难让人理解，这些测试报告虽然篇幅很大，但是如果要从中找到接下来RD要做什么，还是要花费一点时间的。</p>
<p>在测试工作过程中，无论是测试报告，还是风险通报，首先要了解到这些内容的接收者到底是谁，然后需要思考，要以什么样的描述和组织才能方便对方快速了解到内容的含义，也就是要做到：到什么山头，唱什么歌。</p>
<p>我刚入职的时候，因为之前没有做过测试，也不知道测试报告要以什么样的格式来发，所以很害怕发测试报告。虽然学习了其他前辈的测试报告和前辈们的测试报告范式，但是总感觉还是害怕。因为，从RD的角度来看，阅读那些测试报告的成本还是很大的。</p>
<p>然后，我站在RD的角度上想，怎么组织测试报告，才能让RD一眼就知道自己接下来要做什么呢？然后我重新组织了之前测测试报告，在报告的最开始用1句话概括项目的测试结论：该项目测试是否通过，原因是什么？具体的BUG量是多少？然后接下来是详细的测试清单，清单中明确表明每一个case的测试点，前置，预期结果，实际测试结果，是否通过等信息。对于测试通过的case，用绿色来标注；对于测试失败的case，用红色标注；对于有疑问的case，比如建议等，用黄色标注。RD收到测试报告之后，先看结论，然后看非绿色的测试case修复BUG。</p>
<h2 id="原则4：消除门槛，而不是提升门槛"><a href="#原则4：消除门槛，而不是提升门槛" class="headerlink" title="原则4：消除门槛，而不是提升门槛"></a>原则4：消除门槛，而不是提升门槛</h2><p>大禹治水之所以成功，最重要的思想就是：改“堵”为“疏”。</p>
<p>但是真正的测试过程中，经常会发现如下的现象：领导质疑QA的测试时间太长，QA质疑RD的提测质量太差，然后QA增加了准入打回的流程，对于RD提测的、没有通过准入的项目不予测试。</p>
<p>实际上，这种现象就是QA在项目的测试环节设置了一个门槛，而如果这种门槛设置的越来越多，那么对于业务而言也会发生“洪涝灾害”。单从测试团队的角度看，确实增加这个门槛，测试效率提升了，测试时间降低了，但是如果从整个业务的迭代来看，效率并没有提升。</p>
<p>我们提了门槛，发了准入case，增加了流程，这一点也不能说不好。但是我们有没有想过：这些准入case别人看的懂吗？我们怎么设计case能够使得RD自测的时候更加方便呢？即便看懂了，我们怎么保证RD确实执行了呢？我们怎么保证增加的这个流程每次都贯彻落实了呢？</p>
<p>QA不应该是一个门槛设置者，而应该是一种有效的武器。不能用看似合理的各种标准和要求卡住事情，而应该成为帮助团队解决问题的秘密武器。</p>
<p>QA不能只报问题，只说现象，只说RD不靠谱，上线不检查。QA需要思考：</p>
<ul>
<li>我们能为快速迭代做些什么？</li>
<li>我们能做些什么可以帮助RD快速发现自己的代码问题？</li>
<li>我们能做什么可以帮助RD快速发现上线过程异常了？</li>
</ul>
<h2 id="原则5：不断学习，不做伪学习者"><a href="#原则5：不断学习，不做伪学习者" class="headerlink" title="原则5：不断学习，不做伪学习者"></a>原则5：不断学习，不做伪学习者</h2><p>现在，技术更新换代的频率很快，所以一定要不断的学习，持续的学习。还记得刚入职的时候，那时候就会c/c++，java。现在看看自己的github和内网的提交记录，发现语言层面基本上涵盖了：c/c++，java，php，python，go，javascript，shell，object-c，swift，lua。项目类型覆盖了服务端，策略端，iOS，Android，自动化等不同的方向。从原来只会用IIS的小白，到今天了解Apache，Lighttpd，Nginx等各种web服务器。从原来的服务端，到慢慢了解前端，了解策略端，了解客户端。</p>
<p>参加过好多会，和好多人沟通过，大家都希望组织提供学习的机会，提供分享的机会，希望组织能提供自己技术成长的机会。但是，实际上，成长是自己的事，学习是个人的事，为什么要求组织给提供这些机会呢？我组织过很长时间的分享，我也最反对组织大规模的技术学习和分享，因为让太多的伪学习者进入之后，效果并不理想。相反，规模较小的沙龙和讨论对个人的技术成长效果更为明显。伪学习者只是想学习而已，只是想让组织提供学习机会而已，仅此而已。</p>
<p>学习是自己的事情，白天求生存，晚上求发展。凌晨2点的时候，也曾在灯下啃过Nginx的源码，分析一个个的线上问题，没有这些个凌晨2点就不会有《Nginx沉思录》，《Nginx洗冤录》等一系列的总结。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/4.jpg" alt></p>
<h2 id="原则6：做积极的抱怨者，不做消极的抱怨者"><a href="#原则6：做积极的抱怨者，不做消极的抱怨者" class="headerlink" title="原则6：做积极的抱怨者，不做消极的抱怨者"></a>原则6：做积极的抱怨者，不做消极的抱怨者</h2><p>没有“抱怨”就不会有技术的进步，但是反过来说没有“抱怨”就不会存在那么多的失败，一无是处，庸庸碌碌。关键是要看待我们对待“抱怨”的态度。当“抱怨”还仅仅是停留在嘴上，停留在思想上，被“抱怨”所控制时，基本上也就离碌碌无为不远了。当我们开始和“抱怨”对抗时，利用一切技术手段和努力消灭“抱怨”时，技术就开始进步了。所以，我一般不反对抱怨，并一直鼓励大家抱怨，但是接下来我会仔细分析抱怨的原因是什么？技术上需要什么探索才能消灭这些抱怨？</p>
<p>每一个“抱怨”都是一次机会，都是一个机遇，都是一次成长。逢山开路，遇水搭桥，勇往直前。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/5.jpg" alt></p>
<h2 id="原则7：正确认识QA和RD的异同"><a href="#原则7：正确认识QA和RD的异同" class="headerlink" title="原则7：正确认识QA和RD的异同"></a>原则7：正确认识QA和RD的异同</h2><p>天分日夜黑白，季节有春夏秋冬，虽然全栈模式有他的优点，但是四季也有四季的美。文能提笔安天下，武能上马定乾坤。关键是，我们需要对QA和RD有正确的认识。</p>
<p>我们不能按照一个原则来评定事情。比如：老驴拉磨，始终走不出那个圈圈。和日行千里的良马相比，当然老驴要羞愧了。但是如果换个角度，拉磨一天，产面千斤。良马再能跑，也跑不出千斤面。</p>
<p>QA和RD虽然都是研发岗，都是技术体系，那他们的差异在哪呢？</p>
<p>我觉得有以下几点吧：</p>
<ul>
<li>从工作关系上讲，QA是RD的下游，RD是QA的客户。</li>
<li>从工作重点上讲，QA注重分析，而RD注重实践。RD要做的是解决问题，采用任何可能的方法，快速实现需求，快速上线。而QA没有太大的业务压力，可以有更多的时间来思考每一种技术的优势和劣势，有更多的时间来仔细分析和追查每一个bug的深层原因，帮助RD在快速解决问题后可以彻底解决问题，锦上添花。</li>
<li>从涵盖业务上讲，QA关注的业务广度较高，而RD关注业务的深度更高。</li>
</ul>
<p>实际上，技术是一个很广泛的概念，不能认为只有写代码，设计架构才是技术，我们的思维本身就是一种技术。关键是，我们的技术要为业务的发展而存在，而不是孤立的存在。</p>
<p><img src="/2020/02/05/thinking-about-QA-my-years-for-work-as-a-QA/6.jpg" alt></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>测试工作</tag>
      </tags>
  </entry>
</search>
